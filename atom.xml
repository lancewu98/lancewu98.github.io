<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wu&#39;s blog</title>
  
  <subtitle>just for fun</subtitle>
  <link href="https://lancewu98.github.io/atom.xml" rel="self"/>
  
  <link href="https://lancewu98.github.io/"/>
  <updated>2021-07-27T03:16:02.302Z</updated>
  <id>https://lancewu98.github.io/</id>
  
  <author>
    <name>LanceWu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MyBatis入门</title>
    <link href="https://lancewu98.github.io/2021/07/27/mybatis-pian-qi-yi-ji-chu-yong-fa/"/>
    <id>https://lancewu98.github.io/2021/07/27/mybatis-pian-qi-yi-ji-chu-yong-fa/</id>
    <published>2021-07-27T02:26:20.000Z</published>
    <updated>2021-07-27T03:16:02.302Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MyBatis篇其一-——基础用法"><a href="#MyBatis篇其一-——基础用法" class="headerlink" title="MyBatis篇其一 ——基础用法"></a>MyBatis篇其一 ——基础用法</h1><h2 id="1-核心配置文件编写"><a href="#1-核心配置文件编写" class="headerlink" title="1.核心配置文件编写"></a>1.核心配置文件编写</h2><p>mybatis的核心配置文件是放在resources下面的mybatis-config.xml文件，里面配置了一些mybatis的相关设置，文件结构如下：</p><p><img src="https://z3.ax1x.com/2021/07/26/WW81Vx.png" alt="1-1"> </p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8" ?></span><span class="token doctype">&lt;!DOCTYPE configuration        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"        "http://mybatis.org/dtd/mybatis-3-config.dtd"></span><span class="token comment" spellcheck="true">&lt;!--configuration 核心配置文件 这里标签是有顺序的--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span></code></pre><p>注意，<configuration>标签内的子标签是有顺序的，顺序错误IDEA会提示报错</configuration></p><p>下面是几个<configuration>标签内的子标签：</configuration></p><h3 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h3><pre class=" language-xml"><code class="language-xml"> <span class="token comment" spellcheck="true">&lt;!--引入外部配置文件 1.这里可以不自闭合，然后引入配置文件中没有的新的property 2.如果存在同名，优先使用外部配置里的配置--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>db.properties<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pwd<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span></code></pre><pre class=" language-xml"><code class="language-xml"> <span class="token comment" spellcheck="true">&lt;!--引入外部配置文件 1.这里可以不自闭合，然后引入配置文件中没有的新的property 2.如果存在同名，优先使用外部配置里的配置--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>db.properties<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pwd<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span></code></pre><p> 这里的”db.properties”是来自和mybatis-config.xml同一层级目录下的另一个配置文件，里面的信息如下：</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">driver</span><span class="token punctuation">=</span><span class="token attr-value">com.mysql.cj.jdbc.Driver</span><span class="token attr-name">url</span><span class="token punctuation">=</span><span class="token attr-value">jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span></code></pre><p>作用：设置一些配置项，其中包括标签内的配置项和引用外部配置文件。</p><h3 id="settings"><a href="#settings" class="headerlink" title="settings"></a>settings</h3><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--配置--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>settings</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--日志配置--></span>        <span class="token comment" spellcheck="true">&lt;!--&lt;setting name="logImpl" value="STDOUT_LOGGING"/>--></span>        <span class="token comment" spellcheck="true">&lt;!--开启驼峰命名--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mapUnderscoreToCamelCase<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token comment" spellcheck="true">&lt;!--显式地开启全局缓存（二级缓存）--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cacheEnabled<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>settings</span><span class="token punctuation">></span></span></code></pre><p>作用：设置一些mybatis支持的配置，具体支持哪一些详见mybatis官方文档：<a href="https://mybatis.org/mybatis-3/zh/configuration.html#settings">https://mybatis.org/mybatis-3/zh/configuration.html#settings</a></p><h3 id="typeAliases"><a href="#typeAliases" class="headerlink" title="typeAliases"></a>typeAliases</h3><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--给类取别名，就不需要写长限定名了--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeAliases</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--按照长路径div改名--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>typeAlias</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.example.pojo.User<span class="token punctuation">"</span></span> <span class="token attr-name">alias</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>User<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token comment" spellcheck="true">&lt;!--扫描整个包下面的类，把所有类的别名设置为类名的首字母小写,需要修改别名可以在实体类上用@Alias（“别名”）来改--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>package</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.example.pojo<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>typeAliases</span><span class="token punctuation">></span></span></code></pre><p>作用：原本在mybatis里面，映射的实体类需要写实体类的全路径长限定名（如：com.example.pojo.User），使用别名之后可以用设定的别名来代替长限定名</p><h3 id="environments"><a href="#environments" class="headerlink" title="environments"></a>environments</h3><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--可以存在多个环境，默认选择了development--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>environments</span> <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>development<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>environment</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>development<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!--事务管理器 除了JDBC还有一个Managed（旧，现在不用）--></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transactionManager</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>JDBC<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token comment" spellcheck="true">&lt;!--数据源（连接池）除了POOLED还有UNPOOLED(不使用池)，JNDI（旧，现在不用）--></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataSource</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>POOLED<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>driver<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;driver&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                <span class="token comment" spellcheck="true">&lt;!--这里如果url是直接配置，需要把“&amp;”写成“&amp;amp;”进行转义--></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>url<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;url&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;username&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>$&amp;#123;pwd&amp;#125;<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataSource</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>environment</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>environments</span><span class="token punctuation">></span></span></code></pre><p>作用：配置环境。<environments>里面可以包含多个环境，然后通过default来设定默认的环境。环境里面将之前在<properties>标签里面配置的权限项通过 “${ }” 读取出来再设置到数据源dataSource里面</properties></environments></p><h3 id="mappers"><a href="#mappers" class="headerlink" title="mappers"></a>mappers</h3><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--映射器  每一个mapper都需要在这里注册--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mappers</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--resource的路径是“/”而不是“.”--></span>        <span class="token comment" spellcheck="true">&lt;!--使用配置文件写sql的话，映射尽量用resource，用class或者package会有一些限制--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com/example/dao/UserMapper.xml<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token comment" spellcheck="true">&lt;!--使用注解写sql的话，映射用class--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.example.dao.UserMapper4Annotation<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token comment" spellcheck="true">&lt;!--        &lt;mapper class="com.example.dao.TeacherMapper"/>--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>StudentMapper.xml<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">resource</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>TeacherMapper.xml<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.example.dao.BlogMapper<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mappers</span><span class="token punctuation">></span></span></code></pre><p>作用：配置我们设置的mapper。所有的mapper都需要在这里注册，可以用resource和class两种方式，使用方式如上。</p><h2 id="2-读取核心配置文件"><a href="#2-读取核心配置文件" class="headerlink" title="2.读取核心配置文件"></a>2.读取核心配置文件</h2><p>比较通用的方式是写一个工具类，因为配置文件的读取方式是不变的，这部分方法可以抽取出来</p><pre class=" language-MybatisUtils.java"><code class="language-MybatisUtils.java">//sqlSessionFactory -> sqlSessionpublic class MybatisUtils &#123;    //可以理解为数据库连接池，一旦被创建后就应该在应用的运行期间一直存在，没有理由丢弃或重新创建它    //最佳作用域：应用作用域   使用单例或静态单例    private static SqlSessionFactory sqlSessionFactory;    static &#123;        try &#123;            //使用mybatis第一步：获取sqlSessionFactory对象            String resource = "mybatis-config.xml";            InputStream  inputStream = Resources.getResourceAsStream(resource);            //SqlSessionFactoryBuilder:一旦创建了sqlSessionFactory，就不需要它了（做局部变量就行）            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    /**     * 既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。     * SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。     * 可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。     */    //SqlSession可以理解为连接到连接池的一个请求，实例不是线程安全，故不可共享，用完之后需要赶紧关闭    //最佳作用域：请求或方法作用域    //openSession(true)的话自动提交事务    public static SqlSession getSqlSession()&#123;        return sqlSessionFactory.openSession();    &#125;&#125;</code></pre><p>可以看出mybatis创建sqlSession的方式是：</p><p>1.使用InputStream读取设定的核心配置文件</p><p>2.实例化一个SqlSessionFactoryBuilder</p><p>3.根据配置文件内容，通过SqlSessionFactoryBuilder创建一个SqlSessionFactory</p><p>4.调用创建的SqlSessionFactory的openSession()方法创建一个sqlSession</p><h2 id="3-编写查询接口及映射的SQL"><a href="#3-编写查询接口及映射的SQL" class="headerlink" title="3.编写查询接口及映射的SQL"></a>3.编写查询接口及映射的SQL</h2><p>接下来就可以编写查询的接口和接口对应的sql语句了，在此之前注意先编写实体类和创建数据库表</p><p><img src="https://z3.ax1x.com/2021/07/26/WW8MrR.png" alt="2"></p><p>先编写一个实体类User：</p><pre class=" language-User.java"><code class="language-User.java">public class User &#123;    private int id;    private String name;    private String pwd;&#125;//此处略去getter setter toString等</code></pre><p>补一个实体类User2：</p><pre class=" language-User2.java"><code class="language-User2.java">/** * 这个类和User只有一个密码这个字段的差别，是用来测试实体类字段和数据库字段不一样的时候怎么处理 */public class User2 &#123;    private int id;    private String name;    private String password;&#125;</code></pre><p>对应的数据库表和预置数据如下：</p><p><a href="https://imgtu.com/i/WW8KM9"><img src="https://z3.ax1x.com/2021/07/26/WW8KM9.png" alt="WW8KM9.png"></a><br><a href="https://imgtu.com/i/WW8Qq1"><img src="https://z3.ax1x.com/2021/07/26/WW8Qq1.png" alt="WW8Qq1.png"></a></p><p>搞定实体类和数据库表之后，就可以编写接口了：</p><pre class=" language-UserMapper.java"><code class="language-UserMapper.java">public interface UserMapper &#123;    List<User> getUserList();    User getUserById(int id);    int addUser(User user);    int updateUser(User user);    int deleteUser(int id);    int addUserByMap(HashMap<String,Object> map);    List<User> getUserLike(String value);    User2 getUser2ById(int id);    //分页    List<User> getUserByLimit(Map<String,Integer> map);&#125;</code></pre><p>接口需要有实现的功能，我们可以写一个mapper去映射。注意这个mapper写完之后要第一时间注册到核心配置文件的<mappers>标签里面。mapper是一个xml文件，先看看它的结构：</mappers></p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8" ?></span><span class="token doctype">&lt;!DOCTYPE mapper        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"></span><span class="token comment" spellcheck="true">&lt;!--namespace 绑定一个dao/mapper接口 注意路径是.不是/--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.example.dao.UserMapper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">></span></span></code></pre><p>mapper文件内容如上，我们的sql语句就写在<mapper>标签里面，namespace里写刚才编写的接口，用于映射，不然不知道这个mapper是对应哪个接口的，这样接口就和xml关联了起来，调用接口方法就会执行xml里面编写的sql语句。</mapper></p><p>UserMapper.xml的<mapper>标签内的内容：</mapper></p><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--实体类User的查询--></span>    <span class="token comment" spellcheck="true">&lt;!--id：对应namespace里的方法名--></span>    <span class="token comment" spellcheck="true">&lt;!--resultType：sql语句执行的返回值，如果返回值是即可，这里写集合里的泛型即可--></span>    <span class="token comment" spellcheck="true">&lt;!--parameterType：参数类型，如果是基础参数类型可以不写（如int）--></span>    <span class="token comment" spellcheck="true">&lt;!--这里的resultType原本应该写长路径com.example.pojo.User，但是因为在mybatis-config.xml里配置了别名才可以简写成User的--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getUserList<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>User<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    select * from user  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span>       <span class="token comment" spellcheck="true">&lt;!--int的别名是"_int",Integer的别名才是"int"--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getUserById<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>_int<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>User<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select * from user where id = #<span class="token entity" title="&#123;">&amp;#123;</span>id<span class="token entity" title="&#125;">&amp;#125;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--模糊查询，这里可以写 "%"#&amp;#123;value&amp;#125;"%"--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getUserLike<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>User<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select * from user where name like #<span class="token entity" title="&#123;">&amp;#123;</span>value<span class="token entity" title="&#125;">&amp;#125;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--分页查询--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getUserByLimit<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>map<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select * from mybatis.user limit #<span class="token entity" title="&#123;">&amp;#123;</span>startIndex<span class="token entity" title="&#125;">&amp;#125;</span>,#<span class="token entity" title="&#123;">&amp;#123;</span>pageSize<span class="token entity" title="&#125;">&amp;#125;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--实体类User2的查询--></span>    <span class="token comment" spellcheck="true">&lt;!--结果集映射  遇到数据库字段和实体类属性不同时使用，使用的地方就不需要用resultType了--></span>    <span class="token comment" spellcheck="true">&lt;!--property:实体类属性名 column:数据库字段名--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>User2Map<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>User2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--只写需要映射的字段，属性名和字段名一样的不需要显示映射--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pwd<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>getUser2ById<span class="token punctuation">"</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>User2Map<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select id,name,pwd from user where id = #<span class="token entity" title="&#123;">&amp;#123;</span>id<span class="token entity" title="&#125;">&amp;#125;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span></code></pre><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><pre class=" language-xml"><code class="language-xml">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>insert</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>addUser<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>User<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        insert into user (id,name,pwd) values (#<span class="token entity" title="&#123;">&amp;#123;</span>id<span class="token entity" title="&#125;">&amp;#125;</span>,#<span class="token entity" title="&#123;">&amp;#123;</span>name<span class="token entity" title="&#125;">&amp;#125;</span>,#<span class="token entity" title="&#123;">&amp;#123;</span>pwd<span class="token entity" title="&#125;">&amp;#125;</span>)    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>insert</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--使用map，属性名可以任取，只要和map里面的键一样就行。而使用实体类的话不行--></span>    <span class="token comment" spellcheck="true">&lt;!--且使用map可以减少传参的数量，实体类必须new出来--></span>    <span class="token comment" spellcheck="true">&lt;!--这里直接写的“map”是因为这是mybatis对Map的默认别名，如果是基础类型前面加_就可以，如_int对应int，而int是对应Integer--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>insert</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>addUserByMap<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>map<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        insert into user (id,name,pwd) values (#<span class="token entity" title="&#123;">&amp;#123;</span>userId<span class="token entity" title="&#125;">&amp;#125;</span>,#<span class="token entity" title="&#123;">&amp;#123;</span>userName<span class="token entity" title="&#125;">&amp;#125;</span>,#<span class="token entity" title="&#123;">&amp;#123;</span>passWord<span class="token entity" title="&#125;">&amp;#125;</span>)    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>insert</span><span class="token punctuation">></span></span></code></pre><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><pre class=" language-xml"><code class="language-xml">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>update</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>updateUser<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>User<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        update user set name=#<span class="token entity" title="&#123;">&amp;#123;</span>name<span class="token entity" title="&#125;">&amp;#125;</span>,pwd=#<span class="token entity" title="&#123;">&amp;#123;</span>pwd<span class="token entity" title="&#125;">&amp;#125;</span> where id = #<span class="token entity" title="&#123;">&amp;#123;</span>id<span class="token entity" title="&#125;">&amp;#125;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>update</span><span class="token punctuation">></span></span></code></pre><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><pre class=" language-xml"><code class="language-xml">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>delete</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>deleteUser<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>_int<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        delete from user where id=#<span class="token entity" title="&#123;">&amp;#123;</span>id<span class="token entity" title="&#125;">&amp;#125;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>delete</span><span class="token punctuation">></span></span></code></pre><h2 id="4-测试编写的功能"><a href="#4-测试编写的功能" class="headerlink" title="4.测试编写的功能"></a>4.测试编写的功能</h2><p>接口和映射的sql语句写完之后，就可以进行测试了。测试的代码如下：</p><pre class=" language-UserDaoTest.java"><code class="language-UserDaoTest.java">public class UserDaoTest &#123;    @Test    public void test()&#123;        //获取sqlSession        SqlSession sqlSession = MybatisUtils.getSqlSession();        //方式一： getMapper        UserMapper mapper = sqlSession.getMapper(UserMapper.class);//        System.out.println();//        User userById = mapper.getUserById(1);//        System.out.println(userById.toString());        //增删改需要提交事务//        User kelly = new User(4, "Kelly", "23451");//        mapper.addUser(kelly);//        sqlSession.commit();////        mapper.updateUser(new User(3,"Eileen","68875"));//        sqlSession.commit();//        mapper.deleteUser(4);//        sqlSession.commit();//        HashMap<String, Object> map = new HashMap<>(8);//        map.put("userId",5);//        map.put("userName","Bella");//        map.put("passWord","31945");//        mapper.addUserByMap(map);//        sqlSession.commit();//        List<User> userList = mapper.getUserList();//        for (User user : userList) &#123;//            System.out.println(user.toString());//        &#125;//        List<User> userLike = mapper.getUserLike("%l%");//        for (User user : userLike) &#123;//            System.out.println(user.toString());//        &#125;////        User2 user2ById = mapper.getUser2ById(1);//        System.out.println(user2ById.toString());//        Map<String, Integer> map = new HashMap<>(8);//        map.put("startIndex",1);//        map.put("pageSize",2);//        List<User> userByLimit = mapper.getUserByLimit(map);//        for (User user : userByLimit) &#123;//            System.out.println(user.toString());//        &#125;////      用RowBounds进行分页（纯代码式,基于java代码层面实现分页）//        RowBounds rowBounds = new RowBounds(1, 2);//        List<User> users = sqlSession.selectList("com.example.dao.UserMapper.getUserList", null, rowBounds);//        for (User user : users) &#123;//            System.out.println(user.toString());//        &#125;        //关闭资源        sqlSession.close();    &#125;&#125;</code></pre><p>调用编写的接口的步骤：</p><ol><li>通过前面编写的工具类MybatisUtils获取sqlSession</li><li>调用sqlSession的getMapper(Class<t> var1)方法来获取接口</t></li><li>直接使用获取的接口，调用方法就可以执行sql语句了</li></ol><p>测试的时候有个需要注意的点：如果在工具类MybatisUtils调用sqlSessionFactory.openSession()时没有传入true，则默认未开启自动提交事务，在执行修改数据库操作后需要调用以下语句提交一下事务：</p><pre class=" language-java"><code class="language-java">sqlSession<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="5-使用注解实现sql执行"><a href="#5-使用注解实现sql执行" class="headerlink" title="5.使用注解实现sql执行"></a>5.使用注解实现sql执行</h2><p>上述方式是使用的xml配置文件来映射sql语句，mybatis还支持用注解方式来实现和sql语句的关联。</p><pre class=" language-UserMapper4Annotation.java"><code class="language-UserMapper4Annotation.java">public interface UserMapper4Annotation &#123;    @Select("select * from user")    List<User> getUserListByAnnotation();    // 方法存在多个参数时，所有参数前面必须加上@Param(。。。)注解，这里仅用来展示sql语句内#后的内容随@param里的字符串    @Select("select * from user where id = #&#123;id&#125;")    User getUserById(@Param("id")int id2);    @Insert("insert into user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)")    int addUser(User user);    //小心不要把set后面的逗号写成and    @Update("update user set name = #&#123;name&#125;,pwd = #&#123;pwd&#125; where id = #&#123;id&#125;")    int update(User user);    @Delete("delete from user where id = #&#123;id&#125;")    int delUser(int id);&#125;</code></pre><p>具体实现如上，直接在接口上使用注解定义sql语句。注意，这个接口同样要配置到mybatis核心配置文件的<mappers>标签里，且以注解形式的映射方式的，注册<mapper>时一般使用class而不是resource（如果是xml映射一般才有resource）。</mapper></mappers></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MyBatis篇其一-——基础用法&quot;&gt;&lt;a href=&quot;#MyBatis篇其一-——基础用法&quot; class=&quot;headerlink&quot; title=&quot;MyBatis篇其一 ——基础用法&quot;&gt;&lt;/a&gt;MyBatis篇其一 ——基础用法&lt;/h1&gt;&lt;h2 id=&quot;1-核心配</summary>
      
    
    
    
    
    <category term="MyBatis" scheme="https://lancewu98.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Redis入门</title>
    <link href="https://lancewu98.github.io/2020/12/11/redis/"/>
    <id>https://lancewu98.github.io/2020/12/11/redis/</id>
    <published>2020-12-11T12:06:20.000Z</published>
    <updated>2020-12-11T12:06:35.271Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Redis介绍"><a href="#一、Redis介绍" class="headerlink" title="一、Redis介绍"></a>一、Redis介绍</h1><h2 id="1-1-引言"><a href="#1-1-引言" class="headerlink" title="1.1 引言"></a>1.1 引言</h2><p>由于用户量增大，请求数量也随之增大，数据压力过大<br>多台服务器之间，数据不同步。<br>多台服务器之间的锁，已经不存在互斥性了</p><h2 id="1-2-NoSQL"><a href="#1-2-NoSQL" class="headerlink" title="1.2 NoSQL"></a>1.2 NoSQL</h2><p>NoSQL -&gt; 非关系型数据库 -&gt; Not Only SQL<br>Key-Value：Redis<br>文档型：ElasticSearch、Solr、MongoDB<br>面向列：Hbase，Cassandra<br>图形化：Neo4j</p><p>除了关系型数据库都是非关系型数据库。<br>NoSQL只是一种概念，泛指非关系型数据库，和关系型数据库做一个区分</p><h2 id="1-3-Redis介绍"><a href="#1-3-Redis介绍" class="headerlink" title="1.3 Redis介绍"></a>1.3 Redis介绍</h2><p>有一位意大利人，在开发一款LLOOGG的统计页面，因为MySQL的性能不好，自己研发了一款非关系型数据库，并命名Redis。</p><p>Redis（Remote Dictionary Server）即远程字典服务，Redis是由C语言去编写，Redis是一款基于Key-Value的NoSQL，而且Redis是基于内存存储数据的，Redis还提供了多种持久化机制，性能可以达到110000/s读取数据，以及81000/s写入数据，Redis还提供了主从、哨兵以及集群的搭建方式，可以更方便的横向扩展以及垂直扩展</p><h1 id="二、Redis安装"><a href="#二、Redis安装" class="headerlink" title="二、Redis安装"></a>二、Redis安装</h1><h2 id="2-1-安装Redis"><a href="#2-1-安装Redis" class="headerlink" title="2.1 安装Redis"></a>2.1 安装Redis</h2><p>version: ‘3.1’<br>services:<br>  redis:<br>    image: daocloud.io/library/redis:5.0.7<br>    restart: always<br>    container_name: redis<br>    environment:<br>     - TZ=Asia/Shanghai<br>        ports:<br>          - 6379:6379</p><h2 id="2-2-使用Redis-cli连接Redis"><a href="#2-2-使用Redis-cli连接Redis" class="headerlink" title="2.2 使用Redis-cli连接Redis"></a>2.2 使用Redis-cli连接Redis</h2><p> 进去Redis容器的内部<br> docker exec -it 容器id bash<br> 在容器内部，使用redis-cli连接</p><h2 id="2-3-使用图形化界面连接Redis"><a href="#2-3-使用图形化界面连接Redis" class="headerlink" title="2.3 使用图形化界面连接Redis"></a>2.3 使用图形化界面连接Redis</h2><p> 下载地址：<a href="https://github.com/lework/RedisDesktopManager-Windows/releases/tag/2020.5">https://github.com/lework/RedisDesktopManager-Windows/releases/tag/2020.5</a><br> 傻瓜式安装</p><h1 id="三、Redis常用命令"><a href="#三、Redis常用命令" class="headerlink" title="三、Redis常用命令"></a>三、Redis常用命令</h1><h2 id="3-1-Redis存储数据的结构"><a href="#3-1-Redis存储数据的结构" class="headerlink" title="3.1 Redis存储数据的结构"></a>3.1 Redis存储数据的结构</h2><p>常用的5种数据结构</p><p>key-string： 一个key对应一个值。</p><p>key-hash：一个key对应一个Map。</p><p>key-list：一个key对应一个列表。</p><p>key-set：一个key对应一个集合。</p><p>key-zset：一个key对应一个有序的集合。</p><p>另外三种数据结构：</p><p>HyperLogLog：计算近似值的。</p><p>GEO：地理位置。</p><p>BIT：一般存储的也是一个字符串，存储的是一个byte[]</p><p>五种常用的存储数据结构图</p><p> key-string：最常用的，一般用于存储一个值。</p><p> key-hash：存储一个对象数据的。</p><p> key-list：使用list结构实现栈和队列结构。</p><p> key-set：交集、差集和并集的操作。</p><p> key-zset：排行榜、积分存储等操作。</p><h2 id="3-2-String常用命令"><a href="#3-2-String常用命令" class="headerlink" title="3.2 String常用命令"></a>3.2 String常用命令</h2><ol><li><p>添加值<br>set key value</p></li><li><p>取值<br>get key</p></li><li><p>批量操作<br>mset key value [key value…]<br>mget key [key…]</p></li><li><p>自增命令（自增1）<br>incr key</p></li><li><p>自减命令（自减1）<br>decr key</p></li><li><p>自增或自减指定数量<br>incrby key increment<br>decrby key decrement</p></li><li><p>设置值得同时，指定生存时间(每次向Redis添加数据时，尽量都设置上生存时间)<br>setex key second value</p></li><li><p>设置值，如果当前key不存在的话（如果这个key存在，什么事都不做；如果这个key不存在，和set命令一样）<br>setnx key value</p></li><li><p>在key对应的value后追加内容<br>append key value</p></li><li><p>查看value字符串的长度<br>strlen key</p></li></ol><h2 id="3-3-Hash常用命令"><a href="#3-3-Hash常用命令" class="headerlink" title="3.3 Hash常用命令"></a>3.3 Hash常用命令</h2><ol><li><p>存储数据<br>hset key field value</p></li><li><p>获取数据<br>hget key field</p></li><li><p>批量操作<br>hmset key field value [field value …]<br>hmget key field [field…]</p></li><li><p>自增（指定自增的值）<br>hincrby key field increment</p></li><li><p>设置值（如果key-field不存在，那么就正常添加，如果存在，什么事都不做）<br>hsetnx key field value</p></li><li><p>检查field是否存在<br>hexists key field</p></li><li><p>删除key对应的field，可以删除多个<br>hdel key field [field]</p></li><li><p>获取当前hash结构中的全部field和value<br>hgetall key</p></li><li><p>获取当前hash结构中的全部field<br>hkeys key</p></li><li><p>获取当前hash结构中的全部value<br>hvals key</p></li><li><p>获取当前hash结构中field的数量<br>hlen key</p></li></ol><h2 id="3-4-List常用命令"><a href="#3-4-List常用命令" class="headerlink" title="3.4 List常用命令"></a>3.4 List常用命令</h2><ol><li><p>存储数据（从左侧插入数据，从右侧插入数据）<br>lpush key value [value …]<br>rpush key value [value …]</p></li><li><p>存储数据（如果key不存在，什么事都不做，如果key存在，但是不是list结构，什么都不做）<br>lpushx key value<br>rpushx key value</p></li><li><p>修改数据（在存储数据时，指定好你的索引位置，覆盖之前索引位置的数据，index超出整个列表的长度，也会失败）<br>lset key index value</p></li><li><p>弹栈方式获取数据（左侧弹出数据，右侧弹出数据）<br>lpop key<br>rpop key</p></li><li><p>获取指定索引范围的数据（start从0开始，stop输入-1，代表最后一个，-2代表倒数第二个）<br>lrange key start stop</p></li><li><p>获取指定索引位置的数据<br>lindex key index</p></li><li><p>获取整个列表的长度<br>llen key</p></li><li><p>删除列表中的数据（它是删除当前列表中的count个value值，count&gt;0从左侧向右侧删除，count&lt;0从右侧向左侧删除，count==0删除列表中的全部value）<br>lrem key count value</p></li><li><p>保留列表中的数据（保留你指定个索引范围内的数据，超过整个索引范围被移除掉）<br>ltrim key start stop</p></li><li><p>将一个列表中的最后一个数据，插入到另外一个列表的头部位置<br>rpoplpush list1 list2</p></li></ol><h2 id="3-5-Set常用命令（不允许重复、无序）"><a href="#3-5-Set常用命令（不允许重复、无序）" class="headerlink" title="3.5 Set常用命令（不允许重复、无序）"></a>3.5 Set常用命令（不允许重复、无序）</h2><ol><li><p>存储数据<br>sadd key member [member…]</p></li><li><p>获取数据（获取全部数据）<br>smembers key</p></li><li><p>随机获取一个数据（获取的同时，移除数据，count默认为1,代表弹出数据的数量）<br>spop key [count]</p></li><li><p>交集（取多个set集合交集）<br>sinter setl set 2 …</p></li><li><p>并集（获取全部集合中的数据）<br>sunion setl set 2 …</p></li><li><p>差集（获取多个集合中不一样的数据）<br>sdiff setl set2…</p></li><li><p>删除数据<br>srem key member [member…]</p></li><li><p>查看当前的set集合中是否包含这个值<br>sismember key member</p></li></ol><h2 id="3-6-zset常用命令"><a href="#3-6-zset常用命令" class="headerlink" title="3.6 zset常用命令"></a>3.6 zset常用命令</h2><ol><li><p>添加数据（score必须是数值。member不允许重复的。）<br>zadd key score member [score member…]</p></li><li><p>修改member的分数（如果member是存在于key中的，正常增加分数，如果memeber不存在，这个命令就相当于zadd)<br>zincrby key increment member</p></li><li><p>查看指定的member的分数<br>zscore key member</p></li><li><p>获取zset中数据的数量<br>zcard key</p></li><li><p>根据score的范围查询member数量<br>zcount key min max</p></li><li><p>删除zset中的成员<br>zrem key member [member…]I</p></li><li><p>根据分数从小到大排序，获取指定范国内的数据（withscores如果添加这个参数，那么会返回member对应的分数）<br>zrange key start stop [withscores]</p></li><li><p>根据分数从大到小排序，获取指定范围内的数据（withscores如果添加这个参数，那么会返回member对应的分数）<br>zrevrange key start stop [withscores]</p></li><li><p>根据分数的返回去获取member(withscores代表同时返回score,添加1imit,就和MySQL中一样，如果不希望等于min或者max的值被查询出来可以采用‘（分数’相当于&lt;但是不等于的方式，最大值和最小值使用+inf和-inf来标识）<br>zrangebyscore key min max [withscores] [limit offset count]</p></li><li><p>根据分数的返回去获取member(withscores代表同时返回score,添加limit,就和MySQL中一样）<br>zrangebyscore key max min [withscores] [limit offset count]</p></li></ol><h2 id="3-7-key常用命令"><a href="#3-7-key常用命令" class="headerlink" title="3.7 key常用命令"></a>3.7 key常用命令</h2><ol><li><p>查看Redis中的全部的key(pattern:<em>,XXX</em>,*XXX)<br>keys pattern</p></li><li><p>查看某一个key是否存在（1-key存在，0-key不存在）<br>exists key</p></li><li><p>删除key<br>del key [key…]</p></li><li><p>设置key的生存时间，单位为秒，单位为毫秒，设置还能活多久<br>expire key second<br>pexpire key milliseconds</p></li><li><p>设置key的生存时间，单位为秒，单位为毫秒，设置能活到什么时间点<br>expireat key timestamp<br>pexpireat key milliseconds</p></li><li><p>查看key的剩余生存时间，单位为秒，单位为毫秒（-2-当前key不存在，-1-当前key没有设置生存时间，具体剩余的生存时<br>间）<br>ttl key<br>pttl key</p></li><li><p>移除key的生存时间（1 - 移除成功，0 - key不存在生存时间，key不存在）<br>persist key</p></li><li><p>选择操作的库<br>select 0~15</p></li><li><p>移动key到另外一个库中<br>move key db</p></li></ol><h2 id="3-8-库的常用命令"><a href="#3-8-库的常用命令" class="headerlink" title="3.8 库的常用命令"></a>3.8 库的常用命令</h2><ol><li><p>清空当前所在的数据库<br>flushdb</p></li><li><p>清空全部数据库<br>flushall</p></li><li><p>查看当前数据库中有多少个key<br>dbsize</p></li><li><p>查看最后一次操作的时间<br>lastsave</p></li><li><p>实时监控Redis服务接收到的目录<br>monitor</p></li></ol><h1 id="四、Java连接Redis"><a href="#四、Java连接Redis" class="headerlink" title="四、Java连接Redis"></a>四、Java连接Redis</h1><p> Jedis连接Redis,Lettuce连接Redis。</p><h2 id="4-1-Jedis连接Redis"><a href="#4-1-Jedis连接Redis" class="headerlink" title="4.1 Jedis连接Redis"></a>4.1 Jedis连接Redis</h2><p> 创建maven项目</p><p> 导入需要的依赖</p><dependencies>    <!--1、Jedis-->    <dependency>        <groupid>redis.clients</groupid>        <artifactid>jedis</artifactid>        <version>2.9.0</version>    </dependency>    <!--2、Junit测试-->    <dependency>        <groupid>junit</groupid>        <version>4.12</version>    </dependency>    <!--3、Lombok-->    <dependency>        <artifactid>1ombok</artifactid>        <version>1.16.20</version>    </dependency></dependencies> 测试<p>public class Demo1 {<br>    @Test<br>    public void set() {<br>        //1.连接Redis<br>        Jedis jedis = new Jedis(“192.168.199.109”, 6379);<br>        //2.操作Redis - 因为Redis的命令是什么，Jedis的方法就是什么<br>        jedis.set(“name”, “李四”);<br>        //3. 释放资源<br>        jedis.close():<br>    }<br>    @Test<br>    public void get (){<br>        //1.连接Redis<br>        Jedis jedis = new Jedis(“192.168.199.109”, 6379);<br>        //2.操作Redis-因为Redis的命令是什么，Jedis的方法就是什么<br>        String value = jedis.get(“name”) :<br>        System.out.println(value);<br>        //3. 释放资源<br>        jedis.close():<br>    }<br>}</p><h2 id="4-2-Jedis存储一个对象到Redis以byte-形式"><a href="#4-2-Jedis存储一个对象到Redis以byte-形式" class="headerlink" title="4.2 Jedis存储一个对象到Redis以byte[]形式"></a>4.2 Jedis存储一个对象到Redis以byte[]形式</h2><p> 准备一个实体类</p><p>@Data<br>@NoArgsConstructor<br>@A11ArgsConstructor<br>public class User implements Serializable {<br>    private Integer id;<br>    private String name;<br>    private Date birthday;<br>}<br> 导入spring-context依赖</p><!--4.导入spring-context--><dependency>    <groupid>org.springframework</groupid>    <artifactid>spring-context</artifactid>    <version>4.3.18.RELEASE</version></dependency> 创建Demo测试类，编写内容<p>public class Demo2{<br>    //存储对象-以byte[]形式存储在Redis中<br>    @Test<br>    public void setByteArray(){<br>        // 1. 连接Redis服务<br>        Jedis jedis = new Jedis(“192.168.199.109”,6379);<br>        //————————-<br>        // 2.1 准备key(String)-value(User)<br>        String key =”user”;<br>        User value=new User(1,”张三”,new Date());<br>        // 2.2 将key和value转换为byte[]<br>        byte[] byteKey = SerializationUtils.serialize(key);<br>        byte[] byteValue = SerializationUtils.serialize(value);<br>        // 2.3 将key和value存储到Redis<br>        jedis.set(byteKey,byteValue);<br>        //—————————<br>        // 3. 释放资源<br>        jedis.close();<br>    }</p><pre><code>//获取对象 - 以byte[]形式在Redis中获取@Testpublic void getByteArray(){    // 1. 连接Redis服务    Jedis jedis = new Jedis("192.168.199.109",6379);    //-----------------------------    // 2.1 准备key    String key = "user";    // 2.2 将key转换为byte[]    byte[] bytekey=SerializationUtils.serialize(key);    // 2.3 jedis去Redis中获取value    byte[] value=jedis.get(byteKey);    // 2.4 将value反序列化为User对象    User user = (User) SerializationUtils. deserialize(value);    // 2.5 输出    System.out.println("user:"+user);    //------------------------------    // 3. 释放资源    jedis.close();}</code></pre><p>}</p><h2 id="4-3-Jedis存储一个对象到Redis以String的形式"><a href="#4-3-Jedis存储一个对象到Redis以String的形式" class="headerlink" title="4.3 Jedis存储一个对象到Redis以String的形式"></a>4.3 Jedis存储一个对象到Redis以String的形式</h2><p> 导入依赖</p><!--5.导入fastJSON--><dependency>    <artifactid>fastjson</artifactid>    <version>1.2.47</version></dependency> 测试<p>public class Demo3{<br>    //存储对象-以String形式存储<br>    @Test<br>    public void setString(){<br>        //1.连接Redis<br>        Jedis jedis = new Jedis(“192.168.199.109”,6379);<br>        //2.1准备key(String)-value(User)<br>        String stringKey = “stringUser”;<br>        User value = new User(2,”李四”,new Date());<br>        //2.2使用fastJSON将value转化为json字符串<br>        String stringValue = JSON. toJSONString(value);<br>        //2.3存储到Redis中<br>        jedis.set(stringKey,stringValue);<br>        //3.释放资源<br>        jedis.close();</p><pre><code>    //获取对象-以String形式获取    @Test    public void getString(){        //1.连接Redis        Jedis jedis = new Jedis("192.168.199.109",6379);        //2.1准备一个key        String key = "stringUser";        //2.2去Redis中查询value        String value = jedis.get ( key );        //2.3将value反序列化为User        User user = JSON.parseObject(value,User.class);        //2.4输出        System.out.println("user:"+user);        //3. 释放资源        jedis.close();    }}</code></pre><h2 id="4-4-Jedis连接池的操作"><a href="#4-4-Jedis连接池的操作" class="headerlink" title="4.4 Jedis连接池的操作"></a>4.4 Jedis连接池的操作</h2><p>@Test<br>public void pool2(){<br>   //1、创建连接池的配置信息<br>   GenericObjectPoolConfig config = new GenericObjectPoolConfig();<br>   //连接池中最大的活跃数<br>   config.setMaxTotal(100);<br>   //最大空闲数<br>   config.setMaxIdle(10);<br>   //最大空闲数<br>   config.setMinIdle(5);<br>   //当连接池空了之后，多久没获取到jedis对象就超时，单位毫秒<br>   config.setMaxWaitMillis(3000);<br>   //2、创建连接池<br>   JedisPool pool = new JedisPool(config,”127.0.0.1”,6379);<br>   //3、获取jedis<br>   Jedis jedis = pool.getResource();<br>   //4、操作<br>   String value = jedis.get(“stringUser”);<br>   System.out.println(value);<br>   //6、释放连接<br>   jedis.close();<br>}</p><h2 id="4-5-Redis的管道操作"><a href="#4-5-Redis的管道操作" class="headerlink" title="4.5 Redis的管道操作"></a>4.5 Redis的管道操作</h2><p>因为在操作Redis的时候，执行一个命令需要先发送请求到Redis服务器，这个过程需要经历网络延迟，Redis还需要给客户端一个响应。</p><p>如果我需要一次性执行很多个命令，上述的方式效率很低，可以通过Redis的管道，先将命令放到客户端的一个pipeline中，之后一次性的将全部命令发送到Redis服务器，Redis服务一次性的将全部的返回结果响应给客户端。</p><p>//Redis的管道操作<br>@Test<br>public void pipeline(){<br>   //1、创建连接<br>   JedisPool pool = new JedisPool(“127.0.0.1”,6379);<br>   long start = System.currentTimeMillis();<br>   //2、获取一个连接对象<br>   Jedis jedis = pool.getResource();<br>//       //3、执行incr - 10000次<br>//       for (int i = 0; i &lt; 50000; i++) {<br>//           jedis.incr(“pp”);<br>//       }<br>//       //4、释放资源<br>//       jedis.close();<br>   //——————</p><p>   //3、创建管道<br>   Pipeline pipeline = jedis.pipelined();<br>   //4、执行incr - 10000次放到管道中<br>   for (int i = 0; i &lt; 50000; i++) {<br>       pipeline.incr(“qq”);<br>  }<br>   pipeline.syncAndReturnAll();<br>   //5、释放资源<br>   jedis.close();<br>   long end = System.currentTimeMillis();<br>   System.out.println(end-start);<br>}</p><h1 id="五-Redis其他配置及集群"><a href="#五-Redis其他配置及集群" class="headerlink" title="五 Redis其他配置及集群"></a>五 Redis其他配置及集群</h1><p>修改yaml文件，以方便后期修改Redis配置信息</p><p>#指定本 yml 依从的 compose 哪个版本制定的<br>version: ‘3.1’<br>#定义服务<br>services:<br>#定义一个服务<br>redis:<br>   #指定镜像<br>  image: daocloud.io/library/redis:5.0.7<br>   #容器总是从新启动<br>  restart: always<br>   #容器名称<br>  container_name: redis<br>   #添加环境变量。指定时区<br>  environment:<br>    - TZ=Asia/Shanghai<br>   #添加端口映射<br>  ports:<br>    - 6379:6379<br>   #将主机当前目录的conf目录下的redis.conf挂载到容器里的/usr/local/redis.conf。<br>  volumes:<br>    - ./conf/redis.conf:/usr/local/redis.conf<br>   #覆盖容器启动的默认命令。<br>  command: [“redis-server”,”/usr/local/redis.conf”]<br>执行docker命令：</p><p>#停止和删除容器、网络、卷、镜像。先停止和删除之前的redis容器<br>docker-compose down<br>#重新创建容器并后台启动<br>docker-compose up -d</p><h2 id="5-1-Redis的AUTH"><a href="#5-1-Redis的AUTH" class="headerlink" title="5.1 Redis的AUTH"></a>5.1 Redis的AUTH</h2><p>方式一：通过修改Redis的配置文件，实现Redis的密码校验<br>#在./conf/redis.conf里面添加如下配置<br>requirepass 密码</p><p>然后重启redis容器：docker-compose restart<br>三种客户端的连接方式</p><p>redis-cli：在输入正常命令之前，先输入auth密码即可</p><p>图形化界面：在连接Redis的信息中添加上验证的密码</p><p>Jedis客户端：</p><p>第一种：jedis.auth(password);（不推荐）</p><p>第二种：使用JedisPool的方式</p><p>public JedisPool(GenericObjectPoolConfig poolConfig, String host, int port, int timeout, String password)</p><p>方式二：在不修改redis.conf文件的前提下，在第一次连接redis时，输入命令：Config set requirepass 密码，后续再次操作redis时，需要先AUTH做一次校验。（不推荐这种方式）重启之后密码就失效了。</p><h2 id="5-2-Redis的事务"><a href="#5-2-Redis的事务" class="headerlink" title="5.2 Redis的事务"></a>5.2 Redis的事务</h2><p>Redis的事务：一次事务，该成功的成功，该失败的失败。</p><p>先开启事务，执行一系列的命令，但是命令不会立即执行，会被放在一个队列中，如果你执行事务，那么这个队列中的命令全部执行，如果取消事务，一个队列中的命令全部作废。</p><p>开启事务：multi</p><p>输入要执行的命令，命令被放入到一个队列中</p><p>执行事务：exec</p><p>取消事务：discard</p><p>Redis的事务想发挥功能，需要配合watch监听机制</p><p>在开启事务之前，先通过watch命令监听一个或者多个key，在开启事务之后，如果有其他客户端修改了我监听的key，事务会自动取消。</p><p>如果执行了事务或者取消了事务，watch监听自动消除，一般不需要手动执行unwatch释放监听。</p><h2 id="5-3-Redis持久化机制"><a href="#5-3-Redis持久化机制" class="headerlink" title="5.3 Redis持久化机制"></a>5.3 Redis持久化机制</h2><p>RDB方式-默认<br>RDB是Redis默认的持久化机制</p><p>RDB持久化文件，速度比较快，而且存储的是一个二进制的文件，传输起来很方便。</p><p>RDB持久化的时机：</p><p>save 900 1 #在900秒内，有1个key改变，就执行RDB持久化save 300 10  #在300秒内，有10个key改变，就执行RDB持久化save 60 10000 #在60秒内，有10000个key改变，就执行RDB持久化</p><p>RDB无法保证数据的绝对安全</p><p>#RDB主要配置项<br>#持久化时机：在900秒内，有1个key改变，就执行RDB持久化<br>save 900 1<br>#持久化时机：在300秒内，有10个key改变，就执行RDB持久化<br>save 300 10<br>#持久化时机：在60秒内，有10000个key改变，就执行RDB持久化<br>save 60 10000</p><p>#开启RDB持久化的压缩<br>rdbcompression yes<br>#RDB持久化文件的名称<br>dbfilename dump.rdb</p><p>AOF方式<br>AOF持久化机制默认是关闭的，Redis官方推荐同时开启RDB和AOF持久化，更安全，避免数据丢失。在aof无法使用的时候，再用rdb的备份文件做替补恢复</p><p>AOF持久化的速度相对RDB较慢，存储的是一个文本文件，时间久了文件会比较大，传输困难</p><p>AOF持久化机制：</p><p>#每执行一个写操作，立即持久化到AOF文件中，性能比较低</p><p>appendfsync always</p><p>#每秒执行一次持久化appendfsync everysec#会根据你的操作系统不同，环境的不同，在一定时间执行一次持久化</p><p>appendfsync no</p><p>AOF相对RDB更安全，推荐同时开启AOF和RDB。</p><p>#AOF主要配置项<br>#代表开启AOF持久化<br>appendonly yes<br>#AOF文件的名称<br>appendfilename “redis.aof”<br>#AOF持久化执行的时机<br>#每执行一个写操作，立即持久化到AOF文件中，性能比较低<br>appendfsync always<br>#每秒执行一次持久化<br>appendfsync everysec<br>#会根据你的操作系统不同，环境的不同，在一定时间执行一次持久化<br>appendfsync no<br>同时开启RDB和AOF的注意事项：</p><p>如果同时开启了AOF和RDB持久化，那么Redis宕机重启之后，需要加载一个持久化文件，优先选择AOF文件。</p><p>如果先开启了RDB，然后之后开启AOF，如果RDB执行了持久化，那么RDB文件中的内容会被AOF覆盖掉。</p><h2 id="5-4-Redis主从架构"><a href="#5-4-Redis主从架构" class="headerlink" title="5.4 Redis主从架构"></a>5.4 Redis主从架构</h2><p>单机版Redis存在读写瓶颈的问题</p><p><img src="https://i.loli.net/2020/11/28/PnfYNl6qVIUbEik.png" alt="1.png"></p><p>docker-compose.yml文件：</p><p>#指定本 yml 依从的 compose 哪个版本制定的<br>version: ‘3.1’<br>#定义服务<br>services:<br>#定义一个服务<br>redis1:<br>   #指定镜像<br>  image: daocloud.io/library/redis:5.0.7<br>   #容器总是从新启动<br>  restart: always<br>   #容器名称<br>  container_name: redis1<br>   #添加环境变量。指定时区<br>  environment:<br>    - TZ=Asia/Shanghai<br>   #添加端口映射<br>  ports:<br>    - 7001:6379<br>   #将主机当前目录的conf目录下的redis.conf挂载到容器里的/usr/local/redis.conf。<br>  volumes:<br>    - ./conf/redis1.conf:/usr/local/redis.conf<br>   #覆盖容器启动的默认命令。<br>  command: [“redis-server”,”/usr/local/redis.conf”]<br>redis2:<br>   #指定镜像<br>  image: daocloud.io/library/redis:5.0.7<br>   #容器总是从新启动<br>  restart: always<br>   #容器名称<br>  container_name: redis2<br>   #添加环境变量。指定时区<br>  environment:<br>    - TZ=Asia/Shanghai<br>   #添加端口映射<br>  ports:<br>    - 7002:6379<br>   #将主机当前目录的conf目录下的redis.conf挂载到容器里的/usr/local/redis.conf。<br>  volumes:<br>    - ./conf/redis2.conf:/usr/local/redis.conf<br>   #配置链接，redis1容器别名master<br>  links:<br>    - redis1:master<br>   #覆盖容器启动的默认命令。<br>  command: [“redis-server”,”/usr/local/redis.conf”]<br>redis3:<br>   #指定镜像<br>  image: daocloud.io/library/redis:5.0.7<br>   #容器总是从新启动<br>  restart: always<br>   #容器名称<br>  container_name: redis3<br>   #添加环境变量。指定时区<br>  environment:<br>    - TZ=Asia/Shanghai<br>   #添加端口映射<br>  ports:<br>    - 7003:6379<br>   #将主机当前目录的conf目录下的redis.conf挂载到容器里的/usr/local/redis.conf。<br>  volumes:<br>    - ./conf/redis3.conf:/usr/local/redis.conf<br>  links:<br>    - redis1:master<br>   #覆盖容器启动的默认命令。<br>  command: [“redis-server”,”/usr/local/redis.conf”]<br>#redis2和redis3从节点配置 replicaof <masterip> <masterport><br>replicaof master 6379<br>具体操作步骤</masterport></masterip></p><p>在/opt目录下面创建工作目录</p><p>mkdir docker_redis_master_salve</p><p>vi docker-compose.yml</p><p>复制上面配置信息到yml</p><p>在docker_redis_master_salve下创建conf目录</p><p>touch redis1.conf</p><p>touch redis2.conf</p><p>touch redis3.conf</p><p>向redis2.conf和redis3.conf中添加配置：replicaof master 6379</p><h2 id="5-5-哨兵"><a href="#5-5-哨兵" class="headerlink" title="5.5 哨兵"></a>5.5 哨兵</h2><p>哨兵可以帮助我们解决主从架构中的单点故障问题</p><p><img src="https://i.loli.net/2020/11/28/Cqg59p1kv8G4Et7.png" alt="4.png"></p><p><img src="https://i.loli.net/2020/11/28/47yWeLjmChqPAbk.png" alt="2.png"></p><p>修改docker-compose.yml，为了可以在容器内部使用哨兵的配置</p><p>#指定本 yml 依从的 compose 哪个版本制定的<br>version: ‘3.1’<br>#定义服务<br>services:<br>#定义一个服务<br>redis1:<br>   #指定镜像<br>  image: daocloud.io/library/redis:5.0.7<br>   #容器总是从新启动<br>  restart: always<br>   #容器名称<br>  container_name: redis1<br>   #添加环境变量。指定时区<br>  environment:<br>    - TZ=Asia/Shanghai<br>   #添加端口映射<br>  ports:<br>    - 7001:6379<br>   #将主机当前目录的conf目录下的redis.conf挂载到容器里的/usr/local/redis.conf。<br>  volumes:<br>    - ./conf/redis1.conf:/usr/local/redis.conf<br>    - ./conf/sentinel1.conf:/data/sentinel.conf  #添加的内容<br>   #覆盖容器启动的默认命令。<br>  command: [“redis-server”,”/usr/local/redis.conf”]<br>redis2:<br>   #指定镜像<br>  image: daocloud.io/library/redis:5.0.7<br>   #容器总是从新启动<br>  restart: always<br>   #容器名称<br>  container_name: redis2<br>   #添加环境变量。指定时区<br>  environment:<br>    - TZ=Asia/Shanghai<br>   #添加端口映射<br>  ports:<br>    - 7002:6379<br>   #将主机当前目录的conf目录下的redis.conf挂载到容器里的/usr/local/redis.conf。<br>  volumes:<br>    - ./conf/redis2.conf:/usr/local/redis.conf<br>    - ./conf/sentinel2.conf:/data/sentinel.conf  #添加的内容<br>   #配置链接，redis1容器别名master<br>  links:<br>    - redis1:master<br>   #覆盖容器启动的默认命令。<br>  command: [“redis-server”,”/usr/local/redis.conf”]<br>redis3:<br>   #指定镜像<br>  image: daocloud.io/library/redis:5.0.7<br>   #容器总是从新启动<br>  restart: always<br>   #容器名称<br>  container_name: redis3<br>   #添加环境变量。指定时区<br>  environment:<br>    - TZ=Asia/Shanghai<br>   #添加端口映射<br>  ports:<br>    - 7003:6379<br>   #将主机当前目录的conf目录下的redis.conf挂载到容器里的/usr/local/redis.conf。<br>  volumes:<br>    - ./conf/redis3.conf:/usr/local/redis.conf<br>    - ./conf/sentinel3.conf:/data/sentinel.conf  #添加的内容<br>  links:<br>    - redis1:master<br>   #覆盖容器启动的默认命令。<br>  command: [“redis-server”,”/usr/local/redis.conf”]<br>准备哨兵的配置文件，并且在容器内部手动启动哨兵即可</p><p>哨兵基本配置：</p><p>#哨兵需要后台启动<br>daemonize yes<br>#指定Master节点的ip和端口(主) 哨兵 监视 主节节点 主节点IP/名称 端口 2个从节点<br>sentinel monitor master localhost 6379 2<br>#指定Master节点的ip和端口(从) sentinel monitor mymaster 127.0.0.1 6379 2<br>sentinel monitor master master 6379 2<br>#哨兵每隔多久监听一次redis架构，默认为3秒，这里设置1秒好看效果<br>sentinel down-after-milliseconds master 10000<br>./conf/sentinel1.conf</p><p>#哨兵需要后台启动<br>daemonize yes<br>#指定Master节点的ip和端口(主) 哨兵 监视 主节节点 主节点IP/名称 端口 2个从节点<br>sentinel monitor master localhost 6379 2<br>#哨兵每隔多久监听一次redis架构，默认为3秒，这里设置1秒好看效果<br>sentinel down-after-milliseconds master 10000<br>./conf/sentinel2.conf</p><p>#哨兵需要后台启动<br>daemonize yes<br>#指定Master节点的ip和端口(从) sentinel monitor mymaster 127.0.0.1 6379 2<br>sentinel monitor master master 6379 2<br>#哨兵每隔多久监听一次redis架构，默认为3秒，这里设置1秒好看效果<br>sentinel down-after-milliseconds master 10000<br>./conf/sentinel3.conf</p><p>#哨兵需要后台启动<br>daemonize yes<br>#指定Master节点的ip和端口(从) sentinel monitor mymaster 127.0.0.1 6379 2<br>sentinel monitor master master 6379 2<br>#哨兵每隔多久监听一次redis架构，默认为3秒，这里设置1秒好看效果<br>sentinel down-after-milliseconds master 10000<br>修改docker-compose.yml和增加sentinel的配置文件之后重新构建容器。</p><p>docker-compose down<br>docker-compose up -d<br>在Redis容器内部启动sentinel即可，三个容器分别进入启动。</p><p>redis-sentinel sentinel.conf<br>启动成功之后，如果我们down掉redis1这个容器，集群会自动选举redis2或者redis3为Master.</p><h2 id="5-6-Redis集群"><a href="#5-6-Redis集群" class="headerlink" title="5.6 Redis集群"></a>5.6 Redis集群</h2><p>Redis集群在保证主从加哨兵的基本功能之外，还能提升Redis存储数据的能力。</p><p><img src="https://i.loli.net/2020/11/28/WgKDIBEkzCAfvYH.png" alt="3.png"></p><p>搭建集群<br>#docker-compose.yml<br>version: “3.1”<br>services:<br>redis1:<br>  image: daocloud.io/library/redis:5.0.7<br>   #容器总是从新启动<br>  restart: always<br>  container_name: redis1<br>  environment:<br>    - TZ=Asia/Shanghai<br>  ports:<br>    - 7001:7001<br>    - 17001:17001<br>  volumes:<br>    - ./conf/redis1.conf:/usr/local/redis/redis.conf<br>  command: [“redis-server”,”/usr/local/redis/redis.conf”]<br>redis2:<br>  image: daocloud.io/library/redis:5.0.7<br>   #容器总是从新启动<br>  restart: always<br>  container_name: redis2<br>  environment:<br>    - TZ=Asia/Shanghai<br>  ports:<br>    - 7002:7002<br>    - 17002:17002<br>  volumes:<br>    - ./conf/redis2.conf:/usr/local/redis/redis.conf<br>  command: [“redis-server”,”/usr/local/redis/redis.conf”]<br>redis3:<br>  image: daocloud.io/library/redis:5.0.7<br>   #容器总是从新启动<br>  restart: always<br>  container_name: redis3<br>  environment:<br>    - TZ=Asia/Shanghai<br>  ports:<br>    - 7003:7003<br>    - 17003:17003<br>  volumes:<br>    - ./conf/redis3.conf:/usr/local/redis/redis.conf<br>  command: [“redis-server”,”/usr/local/redis/redis.conf”]<br>redis4:<br>  image: daocloud.io/library/redis:5.0.7<br>   #容器总是从新启动<br>  restart: always<br>  container_name: redis4<br>  environment:<br>    - TZ=Asia/Shanghai<br>  ports:<br>    - 7004:7004<br>    - 17004:17004<br>  volumes:<br>    - ./conf/redis4.conf:/usr/local/redis/redis.conf<br>  command: [“redis-server”,”/usr/local/redis/redis.conf”]<br>redis5:<br>  image: daocloud.io/library/redis:5.0.7<br>   #容器总是从新启动<br>  restart: always<br>  container_name: redis5<br>  environment:<br>    - TZ=Asia/Shanghai<br>  ports:<br>    - 7005:7005<br>    - 17005:17005<br>  volumes:<br>    - ./conf/redis5.conf:/usr/local/redis/redis.conf<br>  command: [“redis-server”,”/usr/local/redis/redis.conf”]<br>redis6:<br>  image: daocloud.io/library/redis:5.0.7<br>   #容器总是从新启动<br>  restart: always<br>  container_name: redis6<br>  environment:<br>    - TZ=Asia/Shanghai<br>  ports:<br>    - 7006:7006<br>    - 17006:17006<br>  volumes:<br>    - ./conf/redis6.conf:/usr/local/redis/redis.conf<br>  command: [“redis-server”,”/usr/local/redis/redis.conf”]<br>#redis.conf</p><p>指定redis的端口号<br>port 7001<br>开启redis集群<br>cluster-enabled yes<br>集群信息的文件<br>cluster-config-file nodes-7001.conf<br>集群的对外ip地址<br>cluster-announce-ip 192.168.102.11<br>集群的对外端口号<br>cluster-announce-port 7001<br>集群的总线端口号<br>cluster-announce-bus-port 17001<br>启动6个Redis的节点。</p><p>随便跳转到一个容器内部，使用redis-cli管理集群，他会自动分配好主从节点以及hash槽</p><p>redis-cli –cluster create 192.168.102.11:7001 192.168.102.11:7002 192.168.102.11:7003 192.168.102.11:7004 192.168.102.11:7005 192.168.102.11:7006 –cluster-replicas 1<br>测试</p><p>使用redis-cli -h 192.168.102.11 -p 7001 连接指定一个redis节点，此时set key可能设置不进去，因为通过计算key应该在另外的节点。如果需要在客户端连接，但是set数据能跳转到其他节点set，连接命令需要加-c，如下</p><p>redis-cli -h 192.168.102.11 -p 7001 -c</p><h2 id="5-7-Java连接Redis集群"><a href="#5-7-Java连接Redis集群" class="headerlink" title="5.7 Java连接Redis集群"></a>5.7 Java连接Redis集群</h2><p>使用JedisCluster对象连接Redis集群</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo5</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clusterTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//创建Set&lt;HostAndPort></span>       Set<span class="token operator">&lt;</span>HostAndPort<span class="token operator">></span> nodes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       nodes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HostAndPort</span><span class="token punctuation">(</span><span class="token string">"192.168.102.11"</span><span class="token punctuation">,</span><span class="token number">7001</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       nodes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HostAndPort</span><span class="token punctuation">(</span><span class="token string">"192.168.102.11"</span><span class="token punctuation">,</span><span class="token number">7002</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       nodes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HostAndPort</span><span class="token punctuation">(</span><span class="token string">"192.168.102.11"</span><span class="token punctuation">,</span><span class="token number">7003</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       nodes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HostAndPort</span><span class="token punctuation">(</span><span class="token string">"192.168.102.11"</span><span class="token punctuation">,</span><span class="token number">7004</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       nodes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HostAndPort</span><span class="token punctuation">(</span><span class="token string">"192.168.102.11"</span><span class="token punctuation">,</span><span class="token number">7005</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       nodes<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HostAndPort</span><span class="token punctuation">(</span><span class="token string">"192.168.102.11"</span><span class="token punctuation">,</span><span class="token number">7006</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//创建jedisCluster集群对象</span>       JedisCluster jedisCluster <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisCluster</span><span class="token punctuation">(</span>nodes<span class="token punctuation">)</span><span class="token punctuation">;</span>     String value <span class="token operator">=</span> jedisCluster<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>  }<br>}</p><h1 id="六-Redis常见问题"><a href="#六-Redis常见问题" class="headerlink" title="六 Redis常见问题"></a>六 Redis常见问题</h1><h2 id="6-1-key的生存时间到了，Redis会立即删除吗？"><a href="#6-1-key的生存时间到了，Redis会立即删除吗？" class="headerlink" title="6.1 key的生存时间到了，Redis会立即删除吗？"></a>6.1 key的生存时间到了，Redis会立即删除吗？</h2><p>不会立即删除</p><p>定期删除：</p><p>Redis每隔一段时间就会去查看Redis设置了过期时间的key，会在大概100ms的间隔中默认查看3个key.</p><p>惰性删除</p><p>当去查询一个已经过了生存时间的key时，Redis会先查看当前key的生存时间是否已经到了，直接删除当前key,并且给用户返回一个空值。</p><h2 id="6-2-Redis的淘汰机制"><a href="#6-2-Redis的淘汰机制" class="headerlink" title="6.2 Redis的淘汰机制"></a>6.2 Redis的淘汰机制</h2><p>在Redis内存已经满的时候，添加一个新的数据，就会执行淘汰策略。</p><p>volatile-lru：在内存不足时，Redis会在设置了过期时间的key中淘汰掉一个最近最少使用的key</p><p>allkeys-lru：在内存不足时，Redis会在全部的key中淘汰掉一个最近最少使用的key</p><p>volatile-lfu：在内存不足时，Redis会在设置了过期时间的key中淘汰掉一个最近最少频次使用的key</p><p>allkeys-lfu：在内存不足时，Redis会在全部的key中淘汰掉一个最近最少频次使用的key</p><p>volatile-random：在内存不足时，Redis会在设置了过期时间的key中随机淘汰掉一个key</p><p>allkeys-random：在内存不足时，Redis会在全部的key中随机淘汰掉一个key</p><p>volatile-ttl：在内存不足时，Redis会在设置了过期时间的key中随机淘汰掉一个剩余生存时间最少的key</p><p>noeviction：（默认）：在内存不足时，直接报错</p><p>指定淘汰机制的方式：maxmemory-policy noeviction（具体策略）</p><p>设置Redis最大内存：maxmemory <bytes></bytes></p><h2 id="6-3-缓存的常见问题"><a href="#6-3-缓存的常见问题" class="headerlink" title="6.3 缓存的常见问题"></a>6.3 缓存的常见问题</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>问题出现的原因：查询的数据，Redis中没有，数据库中也没有。如何解决？</p><p>根据Id查询时，如果id是自增的，将id的最大值放到Redis中，在查询数据库之前，直接比较一下id.</p><p>如果id不是整形的，可以将全部id放到set中，在用户查询之前，去set中查看一些是否有这个id.</p><p>获取客户端的ip地址，可以将ip的访问添加限制。</p><p>将访问的key直接在Redis中缓存一个空值，下次访问的时候可直接查redis放回空值</p><p>根据缓存数据Key的设计规则，将不符合规则的key采用布隆过滤器进行过滤</p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>问题出现的原因：缓存中的热点数据，突然到期了，造成大量的请求都去访问数据库，造成数据库宕机</p><p>在访问缓存中没有的时候，添加一个锁，让几个请求去访问数据库，避免数据库宕机</p><p>去掉热点数据的生存时间</p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>问题出现的原因：当大量缓存同时到期时，最终大量的同时去访问数据库，导致数据库宕机</p><p>将缓存中的数据设置不同的生存时间，例如设置为30~60分钟的要给随机时间</p><h3 id="缓存倾斜"><a href="#缓存倾斜" class="headerlink" title="缓存倾斜"></a>缓存倾斜</h3><p>问题出现的原因：热点数据放在一个Reids节点上，导致Redis节点无法承受住大量的请求，最终导致Redis宕机。</p><p>扩展主从架构，搭建多个从节点，缓解Redis的压力</p><p>可以在Tomcat中做JVM缓存，在查询Redis之前，先去查询Tomcat中的缓存。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Redis介绍&quot;&gt;&lt;a href=&quot;#一、Redis介绍&quot; class=&quot;headerlink&quot; title=&quot;一、Redis介绍&quot;&gt;&lt;/a&gt;一、Redis介绍&lt;/h1&gt;&lt;h2 id=&quot;1-1-引言&quot;&gt;&lt;a href=&quot;#1-1-引言&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://lancewu98.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程</title>
    <link href="https://lancewu98.github.io/2020/08/30/java-duo-xian-cheng/"/>
    <id>https://lancewu98.github.io/2020/08/30/java-duo-xian-cheng/</id>
    <published>2020-08-30T07:31:23.000Z</published>
    <updated>2020-08-30T12:59:05.715Z</updated>
    
    <content type="html"><![CDATA[<p><strong>线程的概念</strong></p><p>线程（英语：Thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在Unix System V及SunOS中也被称为轻量进程（Lightweight Processes），但轻量进程更多指内核线程（Kernel Thread），而把用户线程（User Thread）称为线程。</p><p><strong>1.1 线程与进程的区别</strong></p><p><img src="https://i.loli.net/2020/08/30/9mf54FJMsXyAN6C.png" alt="1.png"></p><p>进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程——资源分配的最小单位。线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。线程——程序执行的最小单位。也就是，进程可以包含多个线程，而线程是程序执行的最小单位。</p><p><strong>1.2 线程的状态</strong></p><p><img src="https://i.loli.net/2020/08/30/DZOh49VLxHcfIgo.png" alt="2.png"></p><ul><li>NEW：线程刚创建</li><li>RUNNABLE: 在JVM中正在运行的线程，其中运行状态可以有运行中RUNNING和READY两种状态，由系统调度进行状态改变。</li><li>BLOCKED：线程处于阻塞状态，等待监视锁，可以重新进行同步代码块中执行</li><li>WAITING : 等待状态</li><li>TIMED_WAITING: 调用sleep() join() wait()方法可能导致线程处于等待状态</li><li>TERMINATED: 线程执行完毕，已经退出</li></ul><p><strong>1.3 Notify和Wait</strong></p><p>Notify和Wait 的作用首先看源码给出的解释，这里翻译了一下：Notify：唤醒一个正在等待这个对象的线程监控。如果有任何线程正在等待这个对象，那么它们中的一个被选择被唤醒。选择是任意的，发生在执行的酌情权。一个线程等待一个对象通过调用一个{@code wait}方法进行监视。Notify()需要在同步方法或同步块中调用，即在调用前，线程也必须获得该对象的对象级别锁Wait：导致当前线程等待，直到另一个线程调用{@link java.lang.Object#notify()}方法或{@link java.lang.Object#notifyAll()}方法。换句话说，这个方法的行为就像它简单一样执行调用{@code wait(0)}。当前线程必须拥有该对象的监视器。线程释放此监视器的所有权，并等待另一个线程通知等待该对象的监视器的线程，唤醒通过调用{@code notify}方法或{@code notifyAll}方法。然后线程等待，直到它可以重新取得监视器的所有权，然后继续执行。Wait()的作用是使当前执行代码的线程进行等待，它是Object类的方法，该方法用来将当前线程置入预执行队列中，并且在Wait所在的代码行处停止执行，直到接到通知或被中断为止。在调用Wait方法之前，线程必须获得该对象的对象级别锁，即只能在同步方法或同步块中调用Wait方法。Wait和Sleep的区别：</p><ul><li>它们最大本质的区别是，Sleep()不释放同步锁，Wait()释放同步锁。</li><li>还有用法的上的不同是：Sleep(milliseconds)可以用时间指定来使他自动醒过来，如果时间不到你只能调用Interreput()来强行打断；Wait()可以用Notify()直接唤起。</li><li>这两个方法来自不同的类分别是Thread和Object</li><li>最主要是Sleep方法没有释放锁，而Wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。</li></ul><p><strong>1.4 Thread.sleep() 和Thread.yield()的异同</strong></p><ul><li>相同 ：Sleep()和yield()都会释放CPU。</li><li>不同：Sleep()使当前线程进入停滞状态，所以执行Sleep()的线程在指定的时间内肯定不会执行；yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。Sleep()可使优先级低的线程得到执行的机会，当然也可以让同优先级和高优先级的线程有执行的机会；yield()只能使同优先级的线程有执行的机会。</li></ul><p><strong>1.5 补充：死锁的概念</strong></p><p>死锁：指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。死锁产生的四个必要条件（缺一不可）：</p><ul><li>互斥条件：顾名思义，线程对资源的访问是排他性，当该线程释放资源后下一线程才可进行占用。</li><li>请求和保持：简单来说就是自己拿的不放手又等待新的资源到手。线程T1至少已经保持了一个资源R1占用,但又提出对另一个资源R2请求，而此时，资源R2被其他线程T2占用，于是该线程T1也必须等待，但又对自己保持的资源R1不释放。</li><li>不可剥夺：在没有使用完资源时，其他线性不能进行剥夺。</li><li>循环等待：一直等待对方线程释放资源。</li></ul><p>我们可以根据死锁的四个必要条件破坏死锁的形成。</p><p><strong>1.6 补充：并发和并行的区别</strong></p><p>并发：是指在某个时间段内，多任务交替的执行任务。当有多个线程在操作时，把CPU运行时间划分成若干个时间段,再将时间段分配给各个线程执行。在一个时间段的线程代码运行时，其它线程处于挂起状。并行：是指同一时刻同时处理多任务的能力。当有多个线程在操作时，CPU同时处理这些线程请求的能力。区别就在于CPU是否能同时处理所有任务，并发不能，并行能。</p><p><strong>1.7 补充：线程安全三要素</strong></p><ul><li>原子性：Atomic包、CAS算法、Synchronized、Lock。</li><li>可见性：Synchronized、Volatile（不能保证原子性）。</li><li>有序性：Happens-before规则。</li></ul><p><strong>1.8 补充：如何实现线程安全</strong></p><ul><li>互斥同步：Synchronized、Lock。</li><li>非阻塞同步：CAS。</li><li>无需同步的方案：如果一个方法本来就不涉及共享数据，那它自然就无需任何同步操作去保证正确性。</li></ul><p><strong>1.9 补充：保证线程安全的机制：</strong></p><ul><li>Synchronized关键字</li><li>Lock</li><li>CAS、原子变量</li><li>ThreadLocl：简单来说就是让每个线程，对同一个变量，都有自己的独有副本，每个线程实际访问的对象都是自己的，自然也就不存在线程安全问题了。</li><li>Volatile</li><li>CopyOnWrite写时复制</li></ul><p>随着CPU核心的增多以及互联网迅速发展，单线程的程序处理速度越来越跟不上发展速度和大数据量的增长速度，多线程应运而生，充分利用CPU资源的同时，极大提高了程序处理速度。</p><p><strong>创建线程的方法</strong></p><p>继承Thread类：</p><pre><code>public class ThreadCreateTest &amp;#123;    public static void main(String[] args) &amp;#123;        new MyThread().start();    &amp;#125;&amp;#125;class MyThread extends Thread &amp;#123;    @Override    public void run() &amp;#123;        System.out.println(Thread.currentThread().getName() + "\t" + Thread.currentThread().getId());    &amp;#125;&amp;#125;</code></pre><p>实现Runable接口：</p><pre><code>public class RunableCreateTest &amp;#123;    public static void main(String[] args) &amp;#123;        MyRunnable runnable = new MyRunnable();        new Thread(runnable).start();    &amp;#125;&amp;#125;class MyRunnable implements Runnable &amp;#123;    @Override    public void run() &amp;#123;        System.out.println(Thread.currentThread().getName() + "\t" + Thread.currentThread().getId());    &amp;#125;&amp;#125;</code></pre><p>通过Callable和Future创建线程：</p><pre><code>public class CallableCreateTest &amp;#123;    public static void main(String[] args) throws Exception &amp;#123;         // 将Callable包装成FutureTask，FutureTask也是一种Runnable        MyCallable callable = new MyCallable();        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(callable);        new Thread(futureTask).start();        // get方法会阻塞调用的线程        Integer sum = futureTask.get();        System.out.println(Thread.currentThread().getName() + Thread.currentThread().getId() + "=" + sum);    &amp;#125;&amp;#125;class MyCallable implements Callable&lt;Integer&gt; &amp;#123;    @Override    public Integer call() throws Exception &amp;#123;        System.out.println(Thread.currentThread().getName() + "\t" + Thread.currentThread().getId() + "\t" + new Date() + " \tstarting...");        int sum = 0;        for (int i = 0; i &lt;= 100000; i++) &amp;#123;            sum += i;        &amp;#125;        Thread.sleep(5000);        System.out.println(Thread.currentThread().getName() + "\t" + Thread.currentThread().getId() + "\t" + new Date() + " \tover...");        return sum;    &amp;#125;&amp;#125;</code></pre><p>线程池方式创建：实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承，但可以多实现啊），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。实际开发中，阿里巴巴开发插件一直提倡使用线程池创建线程，原因在下方会解释，所以上面的代码我就只简写了一些Demo。</p><p><strong>2.1 线程池创建线程</strong></p><p>线程池，顾名思义，线程存放的地方。和数据库连接池一样，存在的目的就是为了较少系统开销，主要由以下几个特点：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗（主要）。提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性。Java提供四种线程池创建方式：</p><ul><li>newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li><li>newFixedThreadPool创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li><li>newScheduledThreadPool创建一个定长线程池，支持定时及周期性任务执行。</li><li>newSingleThreadExecutor创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO, LIFO, 优先级）执行。</li></ul><p>通过源码我们得知ThreadPoolExecutor继承自AbstractExecutorService，而AbstractExecutorService实现了ExecutorService。</p><pre><code>public class ThreadPoolExecutor extends AbstractExecutorServicepublic abstract class AbstractExecutorService implements ExecutorService</code></pre><p><img src="https://i.loli.net/2020/08/30/hQVgBWmKLtXbsYk.png" alt="3.png"></p><p><strong>2.2 ThreadPoolExecutor介绍</strong></p><p>实际项目中，用的最多的就是ThreadPoolExecutor这个类，而《阿里巴巴Java开发手册》中强制线程池不允许使用Executors去创建，而是通过New ThreadPoolExecutor实例的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><p><img src="https://i.loli.net/2020/08/30/QHCc9sBMOrDpuZG.png" alt="4.png"></p><p>我们从ThreadPoolExecutor入手多线程创建方式，先看一下线程池创建的最全参数。</p><pre><code>public ThreadPoolExecutor(int corePoolSize,                              int maximumPoolSize,                              long keepAliveTime,                              TimeUnit unit,                              BlockingQueue&lt;Runnable&gt; workQueue,                              ThreadFactory threadFactory,                              RejectedExecutionHandler handler) &amp;#123;        if (corePoolSize &lt; 0 ||            maximumPoolSize &lt;= 0 ||            maximumPoolSize &lt; corePoolSize ||            keepAliveTime &lt; 0)            throw new IllegalArgumentException();        if (workQueue == null || threadFactory == null || handler == null)            throw new NullPointerException();        this.corePoolSize = corePoolSize;        this.maximumPoolSize = maximumPoolSize;        this.workQueue = workQueue;        this.keepAliveTime = unit.toNanos(keepAliveTime);        this.threadFactory = threadFactory;        this.handler = handler;    &amp;#125;</code></pre><p>参数说明如下：</p><ul><li>corePoolSize：线程池的核心线程数，即便线程池里没有任何任务，也会有corePoolSize个线程在候着等任务。</li><li>maximumPoolSize：最大线程数，不管提交多少任务，线程池里最多工作线程数就是maximumPoolSize。</li><li>keepAliveTime：线程的存活时间。当线程池里的线程数大于corePoolSize时，如果等了keepAliveTime时长还没有任务可执行，则线程退出。</li><li>Unit：这个用来指定keepAliveTime的单位，比如秒：TimeUnit.SECONDS。</li><li>BlockingQueue：一个阻塞队列，提交的任务将会被放到这个队列里。</li><li>threadFactory：线程工厂，用来创建线程，主要是为了给线程起名字，默认工厂的线程名字：pool-1-thread-3。</li><li>handler：拒绝策略，当线程池里线程被耗尽，且队列也满了的时候会调用。</li></ul><p><strong>2.2.1 BlockingQueue</strong></p><p>对于BlockingQueue个人感觉还需要单独拿出来说一下。BlockingQueue：阻塞队列，有先进先出（注重公平性）和先进后出（注重时效性）两种，常见的有两种阻塞队列：ArrayBlockingQueue和LinkedBlockingQueue队列的数据结构大致如图：</p><p><img src="https://i.loli.net/2020/08/30/4H9lQWAuNsJZG6I.png" alt="5.png"></p><p>队列一端进入，一端输出。而当队列满时，阻塞。BlockingQueue核心方法：1. 放入数据put2. 获取数据take。常见的两种Queue：</p><p><strong>2.2.2 ArrayBlockingQueue</strong></p><p>基于数组实现，在ArrayBlockingQueue内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数组外，ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。一段代码来验证一下：</p><pre><code>    package map;    import java.util.concurrent.*;    public class MyTestMap &amp;#123;        // 定义阻塞队列大小        private static final int maxSize = 5;        public static void main(String[] args)&amp;#123;            ArrayBlockingQueue&lt;Integer&gt; queue = new ArrayBlockingQueue&lt;Integer&gt;(maxSize);            new Thread(new Productor(queue)).start();            new Thread(new Customer(queue)).start();        &amp;#125;    &amp;#125;    class Customer implements Runnable &amp;#123;        private BlockingQueue&lt;Integer&gt; queue;        Customer(BlockingQueue&lt;Integer&gt; queue) &amp;#123;            this.queue = queue;        &amp;#125;        @Override        public void run() &amp;#123;            this.cusume();        &amp;#125;        private void cusume() &amp;#123;            while (true) &amp;#123;                try &amp;#123;                    int count = (int) queue.take();                    System.out.println("customer正在消费第" + count + "个商品===");                    // 只是为了方便观察输出结果                    Thread.sleep(10);                &amp;#125; catch (InterruptedException e) &amp;#123;                    e.printStackTrace();                &amp;#125;            &amp;#125;        &amp;#125;    &amp;#125;    class Productor implements Runnable &amp;#123;        private BlockingQueue&lt;Integer&gt; queue;        private int count = 1;        Productor(BlockingQueue&lt;Integer&gt; queue) &amp;#123;            this.queue = queue;        &amp;#125;        @Override        public void run() &amp;#123;            this.product();        &amp;#125;        private void product() &amp;#123;            while (true) &amp;#123;                try &amp;#123;                    queue.put(count);                    System.out.println("生产者正在生产第" + count + "个商品");                    count++;                &amp;#125; catch (InterruptedException e) &amp;#123;                    e.printStackTrace();                &amp;#125;            &amp;#125;        &amp;#125;    &amp;#125;//输出如下/**生产者正在生产第1个商品生产者正在生产第2个商品生产者正在生产第3个商品生产者正在生产第4个商品生产者正在生产第5个商品customer正在消费第1个商品===*/</code></pre><p><strong>2.2.3 LinkedBlockingQueue</strong></p><p>基于链表的阻塞队列，内部也维护了一个数据缓冲队列。需要我们注意的是如果构造一个LinkedBlockingQueue对象，而没有指定其容量大小。LinkedBlockingQueue会默认一个类似无限大小的容量（Integer.MAX_VALUE），这样的话，如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽了。</p><p><strong>2.2.4 LinkedBlockingQueue和ArrayBlockingQueue的主要区别</strong></p><ul><li>ArrayBlockingQueue的初始化必须传入队列大小，LinkedBlockingQueue则可以不传入。</li><li>ArrayBlockingQueue用一把锁控制并发，LinkedBlockingQueue俩把锁控制并发，锁的细粒度更细。即前者生产者消费者进出都是一把锁，后者生产者生产进入是一把锁，消费者消费是另一把锁。</li><li>ArrayBlockingQueue采用数组的方式存取，LinkedBlockingQueue用Node链表方式存取。</li></ul><p><strong>2.2.5handler拒绝策略</strong></p><p>Java提供了4种丢弃处理的方法，当然你也可以自己实现，主要是要实现接口：RejectedExecutionHandler中的方法。</p><ul><li>AbortPolicy：不处理，直接抛出异常。</li><li>CallerRunsPolicy：只用调用者所在线程来运行任务，即提交任务的线程。</li><li>DiscardOldestPolicy：LRU策略，丢弃队列里最近最久不使用的一个任务，并执行当前任务。</li><li>DiscardPolicy：不处理，丢弃掉，不抛出异常。</li></ul><p><strong>2.2.6线程池五种状态</strong></p><pre><code>    private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;    private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;    private static final int STOP       =  1 &lt;&lt; COUNT_BITS;    private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;    private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;</code></pre><p>RUNNING：在这个状态的线程池能判断接受新提交的任务，并且也能处理阻塞队列中的任务。</p><p>SHUTDOWN：处于关闭的状态，该线程池不能接受新提交的任务，但是可以处理阻塞队列中已经保存的任务，在线程处于RUNNING状态，调用shutdown()方法能切换为该状态。</p><p>STOP：线程池处于该状态时既不能接受新的任务也不能处理阻塞队列中的任务，并且能中断现在线程中的任务。当线程处于RUNNING和SHUTDOWN状态，调用shutdownNow()方法就可以使线程变为该状态。</p><p>TIDYING：在SHUTDOWN状态下阻塞队列为空，且线程中的工作线程数量为0就会进入该状态，当在STOP状态下时，只要线程中的工作线程数量为0就会进入该状态。</p><p>TERMINATED：在TIDYING状态下调用terminated()方法就会进入该状态。可以认为该状态是最终的终止状态。</p><p>回到线程池创建ThreadPoolExecutor，我们了解了这些参数，再来看看ThreadPoolExecutor的内部工作原理：</p><p><img src="https://i.loli.net/2020/08/30/sFHK8tMfLdINave.png" alt="6.png"></p><ul><li>判断核心线程是否已满，是进入队列，否：创建线程</li><li>判断等待队列是否已满，是：查看线程池是否已满，否：进入等待队列</li><li>查看线程池是否已满，是：拒绝，否创建线程</li></ul><p><strong>2.3深入理解ThreadPoolExecutor</strong></p><p>进入Execute方法可以看到：</p><pre><code>public void execute(Runnable command) &amp;#123;        if (command == null)            throw new NullPointerException();        int c = ctl.get();      //判断当前活跃线程数是否小于corePoolSize,如果小于，则调用addWorker创建线程执行任务        if (workerCountOf(c) &lt; corePoolSize) &amp;#123;            if (addWorker(command, true))                return;            c = ctl.get();        &amp;#125;      //如果不小于corePoolSize，则将任务添加到workQueue队列。        if (isRunning(c) &amp;&amp; workQueue.offer(command)) &amp;#123;            int recheck = ctl.get();            if (! isRunning(recheck) &amp;&amp; remove(command))                reject(command);            else if (workerCountOf(recheck) == 0)                addWorker(null, false);        &amp;#125;      //如果放入workQueue失败，则创建线程执行任务，如果这时创建线程失败(当前线程数不小于maximumPoolSize时)，就会调用reject(内部调用handler)拒绝接受任务。        else if (!addWorker(command, false))            reject(command);    &amp;#125;AddWorker方法：</code></pre><ul><li>创建Worker对象，同时也会实例化一个Thread对象。在创建Worker时会调用threadFactory来创建一个线程。</li><li>然后启动这个线程。</li></ul><p><strong>2.3.1线程池中CTL属性的作用是什么？</strong></p><p>看源码第一反应就是这个CTL到底是个什么东东？有啥用？一番研究得出如下结论：CTL属性包含两个概念：</p><pre><code>    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));    private static int ctlOf(int rs, int wc) &amp;#123; return rs | wc; &amp;#125;</code></pre><ul><li>runState：即rs 表明当前线程池的状态，是否处于Running，Shutdown，Stop，Tidying。</li><li>workerCount：即wc表明当前有效的线程数。</li></ul><p>我们点击workerCount即工作状态记录值，以RUNNING为例，RUNNING = -1 &lt;&lt; COUNT_BITS;，即-1无符号左移COUNT_BITS位，进一步我们得知COUNT_BITS位29，因为Integer位数为31位（2的五次方减一）</p><pre><code>private static final int COUNT_BITS = Integer.SIZE - 3;</code></pre><p>既然是29位那么就是Running的值为：1110 0000 0000 0000 0000 0000 0000 0000</p><p>31~29位 那低28位呢，就是记录当前线程的总线数啦：</p><pre><code>    // Packing and unpacking ctl    private static int runStateOf(int c)     &amp;#123; return c &amp; ~CAPACITY; &amp;#125;    private static int workerCountOf(int c)  &amp;#123; return c &amp; CAPACITY; &amp;#125;    private static int ctlOf(int rs, int wc) &amp;#123; return rs | wc; &amp;#125;</code></pre><p>从上述代码可以看到workerCountOf这个函数传入ctl之后，是通过CTL&amp;CAPACITY操作来获取当前运行线程总数的。也就是RunningState|WorkCount&amp;CAPACITY，算出来的就是低28位的值。因为CAPACITY得到的就是高3位（29-31位）位0，低28位（0-28位）都是1，所以得到的就是ctl中低28位的值。而runStateOf这个方法的话，算的就是RunningState|WorkCount&amp;CAPACITY，高3位的值，因为CAPACITY是CAPACITY的取反，所以得到的就是高3位（29-31位）为1，低28位（0-28位）为0，所以通过&amp;运算后，所得到的值就是高3为的值。简单来说就是ctl中是高3位作为状态值，低28位作为线程总数值来进行存储。</p><p><strong>2.3.2 shutdownNow和shutdown的区别</strong></p><p>看源码发现有两种近乎一样的方法，shutdownNow和shutdown，设计者这么设计自然是有它的道理，那么这两个方法的区别在哪呢？</p><ul><li>shutdown会把线程池的状态改为SHUTDOWN，而shutdownNow把当前线程池状态改为STOP。</li><li>shutdown只会中断所有空闲的线程，而shutdownNow会中断所有的线程。</li><li>shutdown返回方法为空，会将当前任务队列中的所有任务执行完毕；而shutdownNow把任务队列中的所有任务都取出来返回。</li></ul><p><strong>2.3.3 线程复用原理</strong></p><pre><code>final void runWorker(Worker w) &amp;#123;        Thread wt = Thread.currentThread();        Runnable task = w.firstTask;        w.firstTask = null;        w.unlock(); // allow interrupts        boolean completedAbruptly = true;        try &amp;#123;            while (task != null || (task = getTask()) != null) &amp;#123;                w.lock();                // If pool is stopping, ensure thread is interrupted;                // if not, ensure thread is not interrupted.  This                // requires a recheck in second case to deal with                // shutdownNow race while clearing interrupt                if ((runStateAtLeast(ctl.get(), STOP) ||                     (Thread.interrupted() &amp;&amp;                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;                    !wt.isInterrupted())                    wt.interrupt();                try &amp;#123;                    beforeExecute(wt, task);                    Throwable thrown = null;                    try &amp;#123;                        task.run();                    &amp;#125; catch (RuntimeException x) &amp;#123;                        thrown = x; throw x;                    &amp;#125; catch (Error x) &amp;#123;                        thrown = x; throw x;                    &amp;#125; catch (Throwable x) &amp;#123;                        thrown = x; throw new Error(x);                    &amp;#125; finally &amp;#123;                        afterExecute(task, thrown);                    &amp;#125;                &amp;#125; finally &amp;#123;                    task = null;                    w.completedTasks++;                    w.unlock();                &amp;#125;            &amp;#125;            completedAbruptly = false;        &amp;#125; finally &amp;#123;            processWorkerExit(w, completedAbruptly);        &amp;#125;    &amp;#125;</code></pre><p>就是任务在并不只执行创建时指定的firstTask第一任务，还会从任务队列的中自己主动取任务执行，而且是有或者无时间限定的阻塞等待，以保证线程的存活。默认的是不允许。</p><p><strong>2.4 CountDownLatch和CyclicBarrier区别</strong></p><p>countDownLatch是一个计数器，线程完成一个记录一个，计数器递减，只能只用一次。</p><p>CyclicBarrier的计数器更像一个阀门，需要所有线程都到达，然后继续执行，计数器递增，提供Reset功能，可以多次使用。</p><p><strong>3. 多线程间通信的几种方式</strong></p><p>提及多线程又不得不提及多线程通信的机制。首先，要短信线程间通信的模型有两种：共享内存和消息传递，以下方式都是基本这两种模型来实现的。我们来基本一道面试常见的题目来分析：题目：有两个线程A、B，A线程向一个集合里面依次添加元素”abc”字符串，一共添加十次，当添加到第五次的时候，希望B线程能够收到A线程的通知，然后B线程执行相关的业务操作。</p><p><strong>3.1使用volatile关键字</strong></p><pre><code>package thread;/** *  * @author hxz * @description 多线程测试类 * @version 1.0 * @data 2020年2月15日 上午9:10:09 */public class MyThreadTest &amp;#123;    public static void main(String[] args) throws Exception &amp;#123;        notifyThreadWithVolatile();    &amp;#125;    /**     * 定义一个测试     */    private static volatile boolean flag = false;    /**     * 计算I++，当I==5时，通知线程B     * @throws Exception     */    private static void notifyThreadWithVolatile() throws Exception &amp;#123;        Thread thc = new Thread("线程A")&amp;#123;            @Override            public void run() &amp;#123;                for (int i = 0; i &lt; 10; i++) &amp;#123;                    if (i == 5) &amp;#123;                        flag = true;                        try &amp;#123;                            Thread.sleep(500L);                        &amp;#125; catch (InterruptedException e) &amp;#123;                            // TODO Auto-generated catch block                            e.printStackTrace();                        &amp;#125;                        break;                    &amp;#125;                    System.out.println(Thread.currentThread().getName() + "====" + i);                &amp;#125;            &amp;#125;        &amp;#125;;        Thread thd = new Thread("线程B") &amp;#123;            @Override            public void run() &amp;#123;                while (true) &amp;#123;                    // 防止伪唤醒 所以使用了while                    while (flag) &amp;#123;                        System.out.println(Thread.currentThread().getName() + "收到通知");                        System.out.println("do something");                        try &amp;#123;                            Thread.sleep(500L);                        &amp;#125; catch (InterruptedException e) &amp;#123;                            // TODO Auto-generated catch block                            e.printStackTrace();                        &amp;#125;                        return ;                    &amp;#125;                &amp;#125;            &amp;#125;        &amp;#125;;        thd.start();        Thread.sleep(1000L);        thc.start();    &amp;#125;&amp;#125;</code></pre><p>个人认为这是基本上最好的通信方式，因为A发出通知B能够立马接受并Do Something。</p><p><strong>转载</strong></p><p><a href="https://blog.csdn.net/weixin_44104367/article/details/104481510">https://blog.csdn.net/weixin_44104367/article/details/104481510</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;线程的概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;线程（英语：Thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在Uni</summary>
      
    
    
    
    
    <category term="java 多线程" scheme="https://lancewu98.github.io/tags/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>linux操作系统开篇</title>
    <link href="https://lancewu98.github.io/2020/08/30/linux-cao-zuo-xi-tong-kai-pian/"/>
    <id>https://lancewu98.github.io/2020/08/30/linux-cao-zuo-xi-tong-kai-pian/</id>
    <published>2020-08-30T07:30:17.000Z</published>
    <updated>2020-08-30T10:06:01.207Z</updated>
    
    <content type="html"><![CDATA[<p>此篇文章主要会带你介绍 Linux 操作系统，包括 Linux 本身、Linux 如何使用、以及系统调用和 Linux 是如何工作的。</p><h2 id="Linux-简介"><a href="#Linux-简介" class="headerlink" title="Linux 简介"></a>Linux 简介</h2><p>UNIX 是一个交互式系统，用于同时处理多进程和多用户同时在线。为什么要说 UNIX，那是因为 Linux 是由 UNIX 发展而来的，UNIX 是由程序员设计，它的主要服务对象也是程序员。Linux 继承了 UNIX 的设计目标。从智能手机到汽车，超级计算机和家用电器，从家用台式机到企业服务器，Linux 操作系统无处不在。</p><p>大多数程序员都喜欢让系统尽量简单，优雅并具有一致性。举个例子，从最底层的角度来讲，一个文件应该只是一个字节集合。为了实现顺序存取、随机存取、按键存取、远程存取只能是妨碍你的工作。相同的，如果命令</p><pre><code>ls A*</code></pre><p>意味着只列出以 A 为开头的所有文件，那么命令</p><pre><code>rm A*</code></pre><p>应该会移除所有以 A 为开头的文件而不是只删除文件名是 <code>A*</code> 的文件。这个特性也是<code>最小吃惊原则(principle of least surprise)</code></p><blockquote><p>最小吃惊原则一半常用于用户界面和软件设计。它的原型是：该功能或者特征应该符合用户的预期，不应该使用户感到惊讶和震惊。</p></blockquote><p>一些有经验的程序员通常希望系统具有较强的功能性和灵活性。设计 Linux 的一个基本目标是每个应用程序只做一件事情并把他做好。所以编译器只负责编译的工作，编译器不会产生列表，因为有其他应用比编译器做的更好。</p><p>很多人都不喜欢冗余，为什么在 cp 就能描述清楚你想干什么时候还使用 copy？这完全是在浪费宝贵的 <code>hacking time</code>。为了从文件中提取所有包含字符串 <code>ard</code> 的行，Linux 程序员应该输入</p><pre><code>grep ard f</code></pre><h2 id="Linux-接口"><a href="#Linux-接口" class="headerlink" title="Linux 接口"></a>Linux 接口</h2><p>Linux 系统是一种金字塔模型的系统，如下所示</p><p><img src="https://i.loli.net/2020/08/30/cEngFCApekVYWt7.jpg" alt="1.jpg"></p><p>应用程序发起系统调用把参数放在寄存器中(有时候放在栈中)，并发出 <code>trap</code> 系统陷入指令切换用户态至内核态。因为不能直接在 C 中编写 trap 指令，因此 C 提供了一个库，库中的函数对应着系统调用。有些函数是使用汇编编写的，但是能够从 C 中调用。每个函数首先把参数放在合适的位置然后执行系统调用指令。因此如果你想要执行 read 系统调用的话，C 程序会调用 read 函数库来执行。这里顺便提一下，是由 POSIX 指定的库接口而不是系统调用接口。也就是说，POSIX 会告诉一个标准系统应该提供哪些库过程，它们的参数是什么，它们必须做什么以及它们必须返回什么结果。</p><p>除了操作系统和系统调用库外，Linux 操作系统还要提供一些标准程序，比如文本编辑器、编译器、文件操作工具等。直接和用户打交道的是上面这些应用程序。因此我们可以说 Linux 具有三种不同的接口：系统调用接口、库函数接口和应用程序接口</p><p>Linux 中的 <code>GUI(Graphical User Interface)</code> 和 UNIX 中的非常相似，这种 GUI 创建一个桌面环境，包括窗口、目标和文件夹、工具栏和文件拖拽功能。一个完整的 GUI 还包括窗口管理器以及各种应用程序。</p><p><img src="https://i.loli.net/2020/08/30/CviZU6OVsQ2YhBy.jpg" alt="2.jpg"></p><p>Linux 上的 GUI 由 X 窗口支持，主要组成部分是 X 服务器、控制键盘、鼠标、显示器等。当在 Linux 上使用图形界面时，用户可以通过鼠标点击运行程序或者打开文件，通过拖拽将文件进行复制等。</p><h2 id="Linux-组成部分"><a href="#Linux-组成部分" class="headerlink" title="Linux 组成部分"></a>Linux 组成部分</h2><p>事实上，Linux 操作系统可以由下面这几部分构成</p><ul><li><code>引导程序(Bootloader)</code>：引导程序是管理计算机启动过程的软件，对于大多数用户而言，只是弹出一个屏幕，但其实内部操作系统做了很多事情</li><li><code>内核(Kernel)</code>：内核是操作系统的核心，负责管理 CPU、内存和外围设备等。</li><li><code>初始化系统(Init System)</code>：这是一个引导用户空间并负责控制守护程序的子系统。一旦从引导加载程序移交了初始引导，它就是用于管理引导过程的初始化系统。</li><li><code>后台进程(Daemon)</code>：后台进程顾名思义就是在后台运行的程序，比如打印、声音、调度等，它们可以在引导过程中启动，也可以在登录桌面后启动</li><li><code>图形服务器(Graphical server)</code>：这是在监视器上显示图形的子系统。通常将其称为 X 服务器或 X。</li><li><code>桌面环境(Desktop environment)</code>：这是用户与之实际交互的部分，有很多桌面环境可供选择，每个桌面环境都包含内置应用程序，比如文件管理器、Web 浏览器、游戏等</li><li><code>应用程序(Applications)</code>：桌面环境不提供完整的应用程序，就像 Windows 和 macOS 一样，Linux 提供了成千上万个可以轻松找到并安装的高质量软件。</li></ul><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><p>尽管 Linux 应用程序提供了 GUI ，但是大部分程序员仍偏好于使用<code>命令行(command-line interface)</code>，称为<code>shell</code>。用户通常在 GUI 中启动一个 shell 窗口然后就在 shell 窗口下进行工作。</p><p><img src="https://i.loli.net/2020/08/30/ACVEDHmMXPtdZuL.jpg" alt="5.jpg"></p><p>shell 命令行使用速度快、功能更强大、而且易于扩展、并且不会带来<code>肢体重复性劳损(RSI)</code>。</p><p>下面会介绍一些最简单的 bash shell。当 shell 启动时，它首先进行初始化，在屏幕上输出一个 <code>提示符(prompt)</code>，通常是一个百分号或者美元符号，等待用户输入</p><p><img src="https://i.loli.net/2020/08/30/CLP2MzHS8I9Dq7J.jpg" alt="4.jpg"></p><p>等用户输入一个命令后，shell 提取其中的第一个词，这里的词指的是被空格或制表符分隔开的一连串字符。假定这个词是将要运行程序的程序名，那么就会搜索这个程序，如果找到了这个程序就会运行它。然后 shell 会将自己挂起直到程序运行完毕，之后再尝试读入下一条指令。shell 也是一个普通的用户程序。它的主要功能就是读取用户的输入和显示计算的输出。shell 命令中可以包含参数，它们作为字符串传递给所调用的程序。比如</p><pre><code>cp src dest</code></pre><p>会调用 cp 应用程序并包含两个参数 <code>src</code> 和 <code>dest</code>。这个程序会解释第一个参数是一个已经存在的文件名，然后创建一个该文件的副本，名称为 dest。</p><p>并不是所有的参数都是文件名，比如下面</p><pre><code>head -20 file</code></pre><p>第一个参数 -20，会告诉 head 应用程序打印文件的前 20 行，而不是默认的 10 行。控制命令操作或者指定可选值的参数称为<code>标志(flag)</code>，按照惯例标志应该使用 <code>-</code> 来表示。这个符号是必要的，比如</p><pre><code>head 20 file</code></pre><p>是一个完全合法的命令，它会告诉 head 程序输出文件名为 20 的文件的前 10 行，然后输出文件名为 file 文件的前 10 行。Linux 操作系统可以接受一个或多个参数。</p><p>为了更容易的指定多个文件名，shell 支持 <code>魔法字符(magic character)</code>，也被称为<code>通配符(wild cards)</code>。比如，<code>*</code> 可以匹配一个或者多个可能的字符串</p><pre><code>ls *.c</code></pre><p>告诉 ls 列举出所有文件名以 <code>.c</code> 结束的文件。如果同时存在多个文件，则会在后面进行并列。</p><p>另一个通配符是问号，负责匹配任意一个字符。一组在中括号中的字符可以表示其中任意一个，因此</p><pre><code>ls [abc]*</code></pre><p>会列举出所有以 <code>a</code>、<code>b</code> 或者 <code>c</code> 开头的文件。</p><p>shell 应用程序不一定通过终端进行输入和输出。shell 启动时，就会获取 标准输入、标准输出、标准错误文件进行访问的能力。</p><p>标准输出是从键盘输入的，标准输出或者标准错误是输出到显示器的。许多 Linux 程序默认是从标准输入进行输入并从标准输出进行输出。比如</p><pre><code>sort </code></pre><p>会调用 sort 程序，会从终端读取数据(直到用户输入 ctrl-d 结束)，根据字母顺序进行排序，然后将结果输出到屏幕上。</p><p>通常还可以重定向标准输入和标准输出，重定向标准输入使用 <code>&lt;</code> 后面跟文件名。标准输出可以通过一个大于号 <code>&gt;</code> 进行重定向。允许一个命令中重定向标准输入和输出。例如命令</p><pre><code>sort &lt;in &gt;out</code></pre><p>会使 sort 从文件 in 中得到输入，并把结果输出到 out 文件中。由于标准错误没有重定向，所以错误信息会直接打印到屏幕上。从标准输入读入，对其进行处理并将其写入到标准输出的程序称为 <code>过滤器</code>。</p><p>考虑下面由三个分开的命令组成的指令</p><pre><code>sort &lt;in &gt;temp;head -30 &lt;temp;rm temp</code></pre><p>首先会调用 sort 应用程序，从标准输入 in 中进行读取，并通过标准输出到 temp。当程序运行完毕后，shell 会运行 head ，告诉它打印前 30 行，并在标准输出(默认为终端)上打印。最后，temp 临时文件被删除。轻轻的，你走了，你挥一挥衣袖，不带走一片云彩。</p><p>命令行中的第一个程序通常会产生输出，在上面的例子中，产生的输出都不 temp 文件接收。然而，Linux 还提供了一个简单的命令来做这件事，例如下面</p><pre><code>sort &lt;in | head -30</code></pre><p>上面 <code>|</code> 称为竖线符号，它的意思是从 sort 应用程序产生的排序输出会直接作为输入显示，无需创建、使用和移除临时文件。由管道符号连接的命令集合称为<code>管道(pipeline)</code>。例如如下</p><pre><code>grep cxuan *.c | sort | head -30 | tail -5 &gt;f00</code></pre><p>对任意以 <code>.t</code> 结尾的文件中包含 <code>cxuan</code> 的行被写到标准输出中，然后进行排序。这些内容中的前 30 行被 head 出来并传给 tail ，它又将最后 5 行传递给 foo。这个例子提供了一个管道将多个命令连接起来。</p><p>可以把一系列 shell 命令放在一个文件中，然后将此文件作为输入来运行。shell 会按照顺序对他们进行处理，就像在键盘上键入命令一样。包含 shell 命令的文件被称为<code>shell 脚本(shell scripts)</code>。</p><blockquote><p>推荐一个 shell 命令的学习网站：<a href="https://www.shellscript.sh/">https://www.shellscript.sh/</a></p></blockquote><p>shell 脚本其实也是一段程序，shell 脚本中可以对变量进行赋值，也包含循环控制语句比如 if、for、while 等，shell 的设计目标是让其看起来和 C 相似(There is no doubt that C is father)。由于 shell 也是一个用户程序，所以用户可以选择不同的 shell。</p><h2 id="Linux-应用程序"><a href="#Linux-应用程序" class="headerlink" title="Linux 应用程序"></a>Linux 应用程序</h2><p>Linux 的命令行也就是 shell，它由大量标准应用程序组成。这些应用程序主要有下面六种</p><ul><li>文件和目录操作命令</li><li>过滤器</li><li>文本程序</li><li>系统管理</li><li>程序开发工具，例如编辑器和编译器</li><li>其他</li></ul><p>除了这些标准应用程序外，还有其他应用程序比如 Web 浏览器、多媒体播放器、图片浏览器、办公软件和游戏程序等。</p><p>我们在上面的例子中已经见过了几个 Linux 的应用程序，比如 sort、cp、ls、head，下面我们再来认识一下其他 Linux 的应用程序。</p><p>我们先从几个例子开始讲起，比如</p><pre><code>cp a b</code></pre><p>是将 a 复制一个副本为 b ，而</p><pre><code>mv a b</code></pre><p>是将 a 移动到 b ，但是删除原文件。</p><p>上面这两个命令有一些区别，<code>cp</code> 是将文件进行复制，复制完成后会有两个文件 a 和 b；而 <code>mv</code> 相当于是文件的移动，移动完成后就不再有 a 文件。<code>cat</code> 命令可以把多个文件内容进行连接。使用 <code>rm</code> 可以删除文件；使用 <code>chmod</code> 可以允许所有者改变访问权限；文件目录的的创建和删除可以使用 <code>mkdir</code> 和 <code>rmdir</code> 命令；使用 <code>ls</code> 可以查看目录文件，ls 可以显示很多属性，比如大小、用户、创建日期等；sort 决定文件的显示顺序</p><p>Linux 应用程序还包括过滤器 grep，<code>grep</code> 从标准输入或者一个或多个输入文件中提取特定模式的行；<code>sort</code> 将输入进行排序并输出到标准输出；<code>head</code> 提取输入的前几行；tail 提取输入的后面几行；除此之外的过滤器还有 <code>cut</code> 和 <code>paste</code>，允许对文本行的剪切和复制；<code>od</code> 将输入转换为 ASCII ；<code>tr</code> 实现字符大小写转换；<code>pr</code> 为格式化打印输出等。</p><p>程序编译工具使用 <code>gcc</code>；</p><p><code>make</code> 命令用于自动编译，这是一个很强大的命令，它用于维护一个大的程序，往往这类程序的源码由许多文件构成。典型的，有一些是 <code>header files 头文件</code>，源文件通常使用 <code>include</code> 指令包含这些文件，make 的作用就是跟踪哪些文件属于头文件，然后安排自动编译的过程。</p><p>下面列出了 POSIX 的标准应用程序</p><table><thead><tr><th align="left">程序</th><th align="left">应用</th></tr></thead><tbody><tr><td align="left">ls</td><td align="left">列出目录</td></tr><tr><td align="left">cp</td><td align="left">复制文件</td></tr><tr><td align="left">head</td><td align="left">显示文件的前几行</td></tr><tr><td align="left">make</td><td align="left">编译文件生成二进制文件</td></tr><tr><td align="left">cd</td><td align="left">切换目录</td></tr><tr><td align="left">mkdir</td><td align="left">创建目录</td></tr><tr><td align="left">chmod</td><td align="left">修改文件访问权限</td></tr><tr><td align="left">ps</td><td align="left">列出文件进程</td></tr><tr><td align="left">pr</td><td align="left">格式化打印</td></tr><tr><td align="left">rm</td><td align="left">删除一个文件</td></tr><tr><td align="left">rmdir</td><td align="left">删除文件目录</td></tr><tr><td align="left">tail</td><td align="left">提取文件最后几行</td></tr><tr><td align="left">tr</td><td align="left">字符集转换</td></tr><tr><td align="left">grep</td><td align="left">分组</td></tr><tr><td align="left">cat</td><td align="left">将多个文件连续标准输出</td></tr><tr><td align="left">od</td><td align="left">以八进制显示文件</td></tr><tr><td align="left">cut</td><td align="left">从文件中剪切</td></tr><tr><td align="left">paste</td><td align="left">从文件中粘贴</td></tr></tbody></table><h2 id="Linux-内核结构"><a href="#Linux-内核结构" class="headerlink" title="Linux 内核结构"></a>Linux 内核结构</h2><p>在上面我们看到了 Linux 的整体结构，下面我们从整体的角度来看一下 Linux 的内核结构</p><p><img src="https://i.loli.net/2020/08/30/63hQpw8D1kFsZeK.jpg" alt="3.jpg"></p><p>内核直接坐落在硬件上，内核的主要作用就是 I/O 交互、内存管理和控制 CPU 访问。上图中还包括了 <code>中断</code> 和 <code>调度器</code>，中断是与设备交互的主要方式。中断出现时调度器就会发挥作用。这里的低级代码停止正在运行的进程，将其状态保存在内核进程结构中，并启动驱动程序。进程调度也会发生在内核完成一些操作并且启动用户进程的时候。图中的调度器是 dispatcher。</p><blockquote><p>注意这里的调度器是 <code>dispatcher</code> 而不是 <code>scheduler</code>，这两者是有区别的</p><p>scheduler 和 dispatcher 都是和进程调度相关的概念，不同的是 scheduler 会从几个进程中随意选取一个进程；而 dispatcher 会给 scheduler 选择的进程分配 CPU。</p></blockquote><p>然后，我们把内核系统分为三部分。</p><ul><li>I/O 部分负责与设备进行交互以及执行网络和存储 I/O 操作的所有内核部分。</li></ul><p>从图中可以看出 I/O 层次的关系，最高层是一个<code>虚拟文件系统</code>，也就是说不管文件是来自内存还是磁盘中，都是经过虚拟文件系统中的。从底层看，所有的驱动都是字符驱动或者块设备驱动。二者的主要区别就是是否允许随机访问。网络驱动设备并不是一种独立的驱动设备，它实际上是一种字符设备，不过网络设备的处理方式和字符设备不同。</p><p>上面的设备驱动程序中，每个设备类型的内核代码都不同。字符设备有两种使用方式，有<code>一键式</code>的比如 vi 或者 emacs ，需要每一个键盘输入。其他的比如 shell ，是需要输入一行按回车键将字符串发送给程序进行编辑。</p><p>网络软件通常是模块化的，由不同的设备和协议来支持。大多数 Linux 系统在内核中包含一个完整的硬件路由器的功能，但是这个不能和外部路由器相比，路由器上面是<code>协议栈</code>，包括 TCP/IP 协议，协议栈上面是 socket 接口，socket 负责与外部进行通信，充当了门的作用。</p><p>磁盘驱动上面是 I/O 调度器，它负责排序和分配磁盘读写操作，以尽可能减少磁头的无用移动。</p><ul><li>I/O 右边的是内存部件，程序被装载进内存，由 CPU 执行，这里会涉及到虚拟内存的部件，页面的换入和换出是如何进行的，坏页面的替换和经常使用的页面会进行缓存。</li><li>进程模块负责进程的创建和终止、进程的调度、Linux 把进程和线程看作是可运行的实体，并使用统一的调度策略来进行调度。</li></ul><p>在内核最顶层的是系统调用接口，所有的系统调用都是经过这里，系统调用会触发一个 trap，将系统从用户态转换为内核态，然后将控制权移交给上面的内核部件。</p><h2 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&amp;mid=2247492540&amp;idx=2&amp;sn=289fd74358a5d3517b7db020f9311e04&amp;chksm=fa0d8c3dcd7a052b050ca2f50bed0e66b61efadf848dfa7e1e4720b55c7763af704fae9a3f25&amp;mpshare=1&amp;scene=24&amp;srcid=0811CbeShQJE25TkQ5dRSBKF&amp;sharer_sharetime=1597104681306&amp;sharer_shareid=8f0021d867157be678db15b35b9a963d&amp;key=41be2f82f1089626eab37e404da797e6380c2e9fdceddce236ceab65ebcb7580c39b71b4c5472694e197bb6e587ef2358f81e4e8d39c4f2a1aeea6108cb4987319b91e0c848e56d5e093aa60f33b8f51d0254380a6bfb359184d6b82bd5bbfbd81320faaededf2a0be81e311693854c75ba7bb6b2a344ec82b48247d6786b115&amp;ascene=14&amp;uin=MTk5MzI1NjEyOA==&amp;devicetype=Windows+10+x64&amp;version=62090538&amp;lang=zh_CN&amp;exportkey=A4ye2BuNXCKqTA/Vrk83+s8=&amp;pass_ticket=e83yzQu/ia6BTOdDQpH02zY4l0aLYoUOi5QbD2jucebyEmTDempCnWseQkzpe2Ht">https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&amp;mid=2247492540&amp;idx=2&amp;sn=289fd74358a5d3517b7db020f9311e04&amp;chksm=fa0d8c3dcd7a052b050ca2f50bed0e66b61efadf848dfa7e1e4720b55c7763af704fae9a3f25&amp;mpshare=1&amp;scene=24&amp;srcid=0811CbeShQJE25TkQ5dRSBKF&amp;sharer_sharetime=1597104681306&amp;sharer_shareid=8f0021d867157be678db15b35b9a963d&amp;key=41be2f82f1089626eab37e404da797e6380c2e9fdceddce236ceab65ebcb7580c39b71b4c5472694e197bb6e587ef2358f81e4e8d39c4f2a1aeea6108cb4987319b91e0c848e56d5e093aa60f33b8f51d0254380a6bfb359184d6b82bd5bbfbd81320faaededf2a0be81e311693854c75ba7bb6b2a344ec82b48247d6786b115&amp;ascene=14&amp;uin=MTk5MzI1NjEyOA%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090538&amp;lang=zh_CN&amp;exportkey=A4ye2BuNXCKqTA%2FVrk83%2Bs8%3D&amp;pass_ticket=e83yzQu%2Fia6BTOdDQpH02zY4l0aLYoUOi5QbD2jucebyEmTDempCnWseQkzpe2Ht</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;此篇文章主要会带你介绍 Linux 操作系统，包括 Linux 本身、Linux 如何使用、以及系统调用和 Linux 是如何工作的。&lt;/p&gt;
&lt;h2 id=&quot;Linux-简介&quot;&gt;&lt;a href=&quot;#Linux-简介&quot; class=&quot;headerlink&quot; title=&quot;L</summary>
      
    
    
    
    
    <category term="linux" scheme="https://lancewu98.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>SQL语句大全</title>
    <link href="https://lancewu98.github.io/2020/08/30/sql/"/>
    <id>https://lancewu98.github.io/2020/08/30/sql/</id>
    <published>2020-08-30T06:43:49.000Z</published>
    <updated>2020-08-30T07:35:12.818Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL语句大全"><a href="#SQL语句大全" class="headerlink" title="SQL语句大全"></a>SQL语句大全</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p><strong>1、说明：创建数据库<br>CREATE DATABASE database-name</strong><br><strong>2、说明：删除数据库<br>drop database dbname</strong><br><strong>3、说明：备份sql server<br>— 创建 备份数据的 device<br>USE master<br>EXEC sp_addumpdevice ‘disk’, ‘testBack’, ‘c:\mssql7backup\MyNwind_1.dat’<br>— 开始 备份<br>BACKUP DATABASE pubs TO testBack</strong><br><strong>4、说明：创建新表<br>create table tabname(col1 type1 [not null] [primary key],col2 type2 [not null],..)</strong><br><strong>根据已有的表创建新表：</strong><br><strong>A：create table tab_new like tab_old (使用旧表创建新表)</strong><br><strong>B：create table tab_new as select col1,col2… from tab_old definition only<br>5、说明：删除新表<br>drop table tabname</strong><br><strong>6、说明：增加一个列<br>Alter table tabname add column col type**</strong>注<strong>：列增加后将不能删除。DB2中列加上后数据类型也不能改变，唯一能改变的是增加varchar类型的长度。<br>**7、说明：添加主键</strong>： *<em>Alter table tabname add primary key(col)<br>**说明：删除主键： **Alter table tabname drop primary key(col)</em></p><p><strong>8、说明：创建索引</strong>：<strong>create [unique] index idxname on tabname(col….) *<br><strong>删除索引：</strong>drop index idxname**<br>注：索引是不可更改的，想更改必须删除重新建。<br><strong>9**</strong>、说明：创建视图<strong>：create view viewname as select statement<br>**删除视图</strong>：drop view viewname<br><strong>10、说明：几个简单的基本的sql语句<br>选择：</strong>select * from table1 where 范围<br>**插入：</strong>insert into table1(field1,field2) values(value1,value2)<br><strong>删除：</strong>delete from table1 where 范围<strong>更新</strong>：update table1 set field1=value1 where 范围<br><strong>查找</strong>：select * from table1 where field1 like ’%value1%’ —like的语法很精妙，查资料!<br><strong>排序</strong>：select * from table1 order by field1,field2 [desc]<br><strong>总数</strong>：select count as totalcount from table1<br><strong>求和</strong>：select sum(field1) as sumvalue from table1<br><strong>平均</strong>：select avg(field1) as avgvalue from table1<br><strong>最大</strong>：select max(field1) as maxvalue from table1<br><strong>最小</strong>：select min(field1) as minvalue from table1<br><strong>11、说明：几个高级查询运算词<br>A： UNION 运算符</strong><br>UNION 运算符通过组合其他两个结果表（例如 TABLE1 和 TABLE2）并消去表中任何重复行而派生出一个结果表。当 ALL 随 UNION 一起使用时（即 UNION ALL），不消除重复行。两种情况下，派生表的每一行不是来自 TABLE1 就是来自 TABLE2。<br><strong>B：EXCEPT 运算符<br>EXCEPT</strong>运算符通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表。当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行。<br><strong>C：INTERSECT 运算符<br>INTERSECT</strong>运算符通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。当 <strong>ALL</strong>随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。<br><strong>注：</strong>使用运算词的几个查询结果行必须是一致的。<br><strong>12**</strong>、说明：使用外连接<br><strong>A、</strong>left （outer） join<strong>：<br>左外连接（左连接）：结果集几包括连接表的匹配行，也包括左连接表的所有行。<br>SQL: select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c<br>**B：right （outer） join:</strong><br>右外连接(右连接)：结果集既包括连接表的匹配连接行，也包括右连接表的所有行。<br><strong>C：full/cross （outer） join</strong>：<br>全外连接：不仅包括符号连接表的匹配行，还包括两个连接表中的所有记录。<br><strong>12**</strong>、分组:Group by:<br>**  一张表，一旦分组 完成后，查询后只能得到组相关的信息。<br>  <strong>组相关的信息：</strong>（统计信息） count,sum,max,min,avg <strong>分组的标准)<br>**  **在SQLServer中分组时：不能以text,ntext,image类型的字段作为分组依据<br>  在selecte统计函数中的字段，不能和普通的字段放在一起；</strong></p><p><strong>13、对数据库进行操作：<br>  分离数据库</strong>： <strong>sp_detach_db;附加数据库</strong>：<strong>sp_attach_db</strong> 后接表明，附加需要完整的路径名<br><strong>14.**</strong>如何修改数据库的名称:**<br>sp_renamedb ‘old_name’, ‘new_name’</p><h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2><p><strong>1、说明：复制表(只复制结构,源表名：a 新表名：b) (Access可用)<br>法一：</strong>select * into b from a where 1&lt;&gt;1（仅用于SQlServer）<strong>法二：</strong>select top 0 * into b from a<br>**2、说明：拷贝表(拷贝数据,源表名：a 目标表名：b) (Access可用)<br>**insert into b(a, b, c) select d,e,f from b;</p><p>**3、说明：跨数据库之间表的拷贝(具体数据使用绝对路径) (Access可用)<br>**insert into b(a, b, c) select d,e,f from b in ‘具体数据库’ where 条件<br>例子：..from b in ‘“&amp;Server.MapPath(“.”)&amp;”\data.mdb” &amp;”‘ where..</p><p>**4、说明：子查询(表名1：a 表名2：b)<br>**select a,b,c from a where a IN (select d from b ) 或者: select a,b,c from a where a IN (1,2,3)</p><p>**5、说明：显示文章、提交人和最后回复时间<br>**select a.title,a.username,b.adddate from table a,(select max(adddate) adddate from table where table.title=a.title) b</p><p>**6、说明：外连接查询(表名1：a 表名2：b)<br>**select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c</p><p>**7、说明：在线视图查询(表名1：a )<br>**select * from (SELECT a,b,c FROM a) T where t.a &gt; 1;</p><p>**8、说明：between的用法,between限制查询数据范围时包括了边界值,not between不包括<br>**select * from table1 where time between time1 and time2<br>select a,b,c, from table1 where a not between 数值1 and 数值2</p><p>**9、说明：in 的使用方法<br>**select * from table1 where a [not] in (‘值1’,’值2’,’值4’,’值6’)</p><p>**10、说明：两张关联表，删除主表中已经在副表中没有的信息<br>**delete from table1 where not exists ( select * from table2 where table1.field1=table2.field1 )</p><p>**11、说明：四表联查问题：<br>**select * from a left inner join b on a.a=b.b right inner join c on a.a=c.c inner join d on a.a=d.d where …..</p><p>**12、说明：日程安排提前五分钟提醒<br>**SQL: select * from 日程安排 where datediff(‘minute’,f开始时间,getdate())&gt;5</p><p><strong>13**</strong>、说明：一条*<strong><em>sql** <strong>语句搞定数据库分页</strong>select top 10 b.</em> from (select top 20 主键字段,排序字段 from 表名 order by 排序字段 desc) a,表名 b where b.主键字段 = a.主键字段 order by a.排序字段</strong>具体实现：**关于数据库分页：</p><p> declare @start int,@end int</p><p> @sql nvarchar(600)</p><p> set @sql=’select top’+str(@end-@start+1)+’+from T where rid not in(select top’+str(@str-1)+’Rid from T where Rid&gt;-1)’</p><p> exec sp_executesql @sql</p><p><strong>注意：在**</strong>top**<strong>后不能直接跟一个变量，所以在实际应用中只有这样的进行特殊的处理。**</strong>Rid**<strong>为一个标识列，如果**</strong>top**<strong>后还有具体的字段，这样做是非常有好处的。因为这样可以避免</strong> <strong>top**</strong>的字段如果是逻辑索引的，查询的结果后实际表中的不一致（**<strong>逻辑索引中的数据有可能和数据表中的不一致，而查询时如果处在索引则首先查询索引**</strong>）**</p><p>**14、说明：前10条记录<br>**select top 10 * form table1 where 范围</p><p>**15、说明：选择在每一组b值相同的数据中对应的a最大的记录的所有信息(类似这样的用法可以用于论坛每月排行榜,每月热销产品分析,按科目成绩排名,等等.)<br>**select a,b,c from tablename ta where a=(select max(a) from tablename tb where tb.b=ta.b)</p><p>**16、说明：包括所有在 TableA中但不在 TableB和TableC中的行并消除所有重复行而派生出一个结果表<br>**(select a from tableA ) except (select a from tableB) except (select a from tableC)</p><p>*<em>17、说明：随机取出10条数据<br>**select top 10 * from tablename order by *</em>newid()**</p><p>**18、说明：随机选择记录<br>**select newid()</p><p><strong>19、说明：删除重复记录<br>1),**delete from tablename where id not in (select max(id) from tablename group by col1,col2,…)<br>**2)</strong>,select distinct * into temp from tablename<br> delete from tablename<br> insert into tablename select * from temp<br><strong>评价：这种操作牵连大量的数据的移动，这种做法不适合大容量但数据操作3),例如：在一个外部表中导入数据，由于某些原因第一次只导入了一部分，但很难判断具体位置，这样只有在下一次全部导入，这样也就产生好多重复的字段，怎样删除重复字段</strong></p><p>alter table tablename<br>–添加一个自增列<br>add column_b int identity(1,1)<br> delete from tablename where column_b not in(<br>select max(column_b) from tablename group by column1,column2,…)<br>alter table tablename drop column column_b</p><p>**20、说明：列出数据库里所有的表名<br>**select name from sysobjects where type=’U’ // U代表用户</p><p>**21、说明：列出表里的所有的列名<br>**select name from syscolumns where id=object_id(‘TableName’)</p><p>**22、说明：列示type、vender、pcs字段，以type字段排列，case可以方便地实现多重选择，类似select 中的case。<br>**select type,sum(case vender when ‘A’ then pcs else 0 end),sum(case vender when ‘C’ then pcs else 0 end),sum(case vender when ‘B’ then pcs else 0 end) FROM tablename group by type<br>**显示结果：<br>type vender pcs<br>**电脑 A 1<br>电脑 A 1<br>光盘 B 2<br>光盘 A 2<br>手机 B 3<br>手机 C 3</p><p><strong>23、说明：初始化表table1</strong></p><p>TRUNCATE TABLE table1</p><p>**24、说明：选择从10到15的记录<br>**select top 5 * from (select top 15 * from table order by id asc) table_别名 order by id desc</p><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><p><strong>1、1=1，1=2的使用，在SQL语句组合时用的较多</strong></p><p><strong>“where 1=1” 是表示选择全部  “where 1=2”全部不选，</strong><br>如：<br>if @strWhere !=’’<br>begin<br>set @strSQL = ‘select count(<em>) as Total from [‘ + @tblName + ‘] where ‘ + @strWhere<br>end<br>else<br>begin<br>set @strSQL = ‘select count(</em>) as Total from [‘ + @tblName + ‘]’<br>end</p><p><strong>我们可以直接写成</strong></p><p>错误！未找到目录项。**<br>set @strSQL = ‘select count(*) as Total from [‘ + @tblName + ‘] where 1=1 安定 ‘+ @strWhere 2、收缩数据库<br>**–重建索引<br>DBCC REINDEX<br>DBCC INDEXDEFRAG<br>–收缩数据和日志<br>DBCC SHRINKDB<br>DBCC SHRINKFILE</p><p>**3、压缩数据库<br>**dbcc shrinkdatabase(dbname)</p><p>**4、转移数据库给新用户以已存在用户权限<br>**exec sp_change_users_login ‘update_one’,’newname’,’oldname’<br>go</p><p>**5、检查备份集<br>**RESTORE VERIFYONLY from disk=’E:\dvbbs.bak’</p><p>**6、修复数据库<br>**ALTER DATABASE [dvbbs] SET SINGLE_USER<br>GO<br>DBCC CHECKDB(‘dvbbs’,repair_allow_data_loss) WITH TABLOCK<br>GO<br>ALTER DATABASE [dvbbs] SET MULTI_USER<br>GO</p><p>**7、日志清除<br>**SET NOCOUNT ON<br>DECLARE @LogicalFileName sysname,<br> @MaxMinutes INT,<br> @NewSize INT</p><p>USE tablename – 要操作的数据库名<br>SELECT @LogicalFileName = ‘tablename_log’, – 日志文件名<br>@MaxMinutes = 10, – Limit on time allowed to wrap log.<br> @NewSize = 1 – 你想设定的日志文件的大小(M)</p><p>Setup / initialize<br>DECLARE @OriginalSize int<br>SELECT @OriginalSize = size<br> FROM sysfiles<br> WHERE name = @LogicalFileName<br>SELECT ‘Original Size of ‘ + db_name() + ‘ LOG is ‘ +<br> CONVERT(VARCHAR(30),@OriginalSize) + ‘ 8K pages or ‘ +<br> CONVERT(VARCHAR(30),(@OriginalSize*8/1024)) + ‘MB’<br> FROM sysfiles<br> WHERE name = @LogicalFileName<br>CREATE TABLE DummyTrans<br> (DummyColumn char (8000) not null)</p><p>DECLARE @Counter  INT,<br> @StartTime DATETIME,<br> @TruncLog  VARCHAR(255)<br>SELECT @StartTime = GETDATE(),<br> @TruncLog = ‘BACKUP LOG ‘ + db_name() + ‘ WITH TRUNCATE_ONLY’</p><p>DBCC SHRINKFILE (@LogicalFileName, @NewSize)<br>EXEC (@TruncLog)<br>– Wrap the log if necessary.<br>WHILE @MaxMinutes &gt; DATEDIFF (mi, @StartTime, GETDATE()) – time has not expired<br> AND @OriginalSize = (SELECT size FROM sysfiles WHERE name = @LogicalFileName)<br> AND (@OriginalSize * 8 /1024) &gt; @NewSize<br> BEGIN – Outer loop.<br>SELECT @Counter = 0<br> WHILE  ((@Counter &lt; @OriginalSize / 16) AND (@Counter &lt; 50000))<br> BEGIN – update<br> INSERT DummyTrans VALUES (‘Fill Log’) DELETE DummyTrans<br> SELECT @Counter = @Counter + 1<br> END<br> EXEC (@TruncLog)<br> END<br>SELECT ‘Final Size of ‘ + db_name() + ‘ LOG is ‘ +<br> CONVERT(VARCHAR(30),size) + ‘ 8K pages or ‘ +<br> CONVERT(VARCHAR(30),(size*8/1024)) + ‘MB’<br> FROM sysfiles<br> WHERE name = @LogicalFileName<br>DROP TABLE DummyTrans<br>SET NOCOUNT OFF</p><p>**8、说明：更改某个表<br>**exec sp_changeobjectowner ‘tablename’,’dbo’</p><p><strong>9、存储更改全部表</strong></p><p>CREATE PROCEDURE dbo.User_ChangeObjectOwnerBatch<br>@OldOwner as NVARCHAR(128),<br>@NewOwner as NVARCHAR(128)<br>AS</p><p>DECLARE @Name  as NVARCHAR(128)<br>DECLARE @Owner  as NVARCHAR(128)<br>DECLARE @OwnerName  as NVARCHAR(128)</p><p>DECLARE curObject CURSOR FOR<br>select ‘Name’  = name,<br>  ‘Owner’  = user_name(uid)<br>from sysobjects<br>where user_name(uid)=@OldOwner<br>order by name</p><p>OPEN  curObject<br>FETCH NEXT FROM curObject INTO @Name, @Owner<br>WHILE(@@FETCH_STATUS=0)<br>BEGIN<br>if @Owner=@OldOwner<br>begin<br>  set @OwnerName = @OldOwner + ‘.’ + rtrim(@Name)<br>  exec sp_changeobjectowner @OwnerName, @NewOwner<br>end<br>– select @name,@NewOwner,@OldOwner</p><p>FETCH NEXT FROM curObject INTO @Name, @Owner<br>END</p><p>close curObject<br>deallocate curObject<br>GO</p><p><strong>10、SQL SERVER中直接循环写入数据<br><strong>declare @i int<br>set @i=1<br>while @i&lt;30<br>begin<br>  insert into test (userid) values(@i)<br>  set @i=@i+1<br>end<br>**案例</strong></strong>：<br>**<strong>有如下表，要求就裱中所有沒有及格的成績，在每次增長0.1的基礎上，使他們剛好及格:</strong></p><p>  Name   score</p><p>  Zhangshan  80</p><p>  Lishi    59</p><p>  Wangwu   50</p><p>  Songquan  69</p><p><strong>while((select</strong> <strong>min**</strong>(score) from tb_table)&lt;<strong><strong>60</strong></strong>)**</p><p><strong>begin</strong></p><p><strong>update tb_table set score</strong> <strong>=**</strong>score***<strong>1.01</strong></p><p><strong>where score**</strong>&lt;60**</p><p><strong>if (select</strong> <strong>min**</strong>(score) from tb_table)<strong>**&gt;60</strong></p><p> <strong>break</strong></p><p> <strong>else</strong></p><p>  <strong>continue</strong></p><p><strong>end</strong></p><p><strong>数据开发-经典</strong></p><p><strong>1.按姓氏笔画排序:</strong><br>Select * From TableName Order By CustomerName Collate Chinese_PRC_Stroke_ci_as //从少到多</p><p>**2.数据库加密:**select encrypt(‘原始密码’)<br>select pwdencrypt(‘原始密码’)<br>select pwdcompare(‘原始密码’,’加密后密码’) = 1–相同；否则不相同 encrypt(‘原始密码’)<br>select pwdencrypt(‘原始密码’)<br>select pwdcompare(‘原始密码’,’加密后密码’) = 1–相同；否则不相同</p><p>**3.取回表中字段:<br>**declare @list varchar(1000),<br>@sql nvarchar(1000)<br>select @list=@list+’,’+b.name from sysobjects a,syscolumns b where a.id=b.id and a.name=’表A’<br>set @sql=’select ‘+right(@list,len(@list)-1)+’ from 表A’<br>exec (@sql)</p><p><strong>4.查看硬盘分区:<br>EXEC master..xp_fixeddrives</strong></p><p>*<em>5.比较A,B表是否相等:<br>**if (select checksum_agg(binary_checksum(</em>)) from A)<br>   =<br>  (select checksum_agg(binary_checksum(*)) from B)<br>print ‘相等’<br>else<br>print ‘不相等’</p><p>**6.杀掉所有的事件探察器进程:<br>**DECLARE hcforeach CURSOR GLOBAL FOR SELECT ‘kill ‘+RTRIM(spid) FROM master.dbo.sysprocesses<br>WHERE program_name IN(‘SQL profiler’,N’SQL 事件探查器’)<br>EXEC sp_msforeach_worker ‘?’</p><p><strong>7.**</strong>记录搜索*<strong><em>:<br><strong><strong>开头到</strong></strong>N**<strong>条记录</strong>Select Top N * From 表——————————-<br>*</em>N**</strong>到*<strong><em>M**<strong>条记录**</strong>(<strong><strong>要有主索引</strong></strong>ID)<br>**Select Top M-N * From 表 Where ID in (Select Top M ID From 表) Order by ID  Desc<br>-———————————<br>*</em>N**</strong>到结尾记录*<em>Select Top N * From 表 Order by ID Desc<br>*</em>案例**<strong>例如1：一张表有一万多条记录，表的第一个字段 RecID 是自增长字段， 写一个SQL语句， 找出表的第**</strong>31**<strong>到第**</strong>40**<strong>个记录。</strong></p><p> select top 10 recid from A where recid not in(select top 30 recid from A)</p><p>分析：如果这样写会产生某些问题，如果recid在表中存在逻辑索引。</p><p>  select top 10 recid from A where……是从索引中查找，而后面的select top 30 recid from A则在数据表中查找，这样由于索引中的顺序有可能和数据表中的不一致，这样就导致查询到的不是本来的欲得到的数据。</p><p><strong>解决方案</strong></p><p><strong>1，**</strong>用order by** select top 30 recid from A order by ricid <strong>如果该字段不是自增长，就会出现问题</strong></p><p><strong>2，**</strong>在那个子查询中也加条件：**select top 30 recid from A where recid&gt;-1</p><p><strong>例2**</strong>：查询表中的最后以条记录，并不知道这个表共有多少数据,<strong>*<em>以及表结构。<br>set @s = ‘select top 1 \</em> from T  where pid not in (select top ‘ + str(@count-1) + ‘ pid from T)’</strong></p><p><strong>print @s   exec sp_executesql @s</strong></p><p><strong>9：获取当前数据库中的所有用户表</strong><br>select Name from sysobjects where xtype=’u’ and status&gt;=0</p><p>**10：获取某一个表的所有字段<br>**select name from syscolumns where id=object_id(‘表名’)</p><p>select name from syscolumns where id in (select id from sysobjects where type = ‘u’ and name = ‘表名’)</p><p>两种方式的效果相同</p><p><strong>11：查看与某一个表相关的视图、存储过程、函数</strong>select a.* from sysobjects a, syscomments b where a.id = b.id and b.text like ‘%表名%’</p><p>**12：查看当前数据库中所有存储过程<br>**select name as 存储过程名称 from sysobjects where xtype=’P’</p><p><strong>13：查询用户创建的所有数据库</strong>select * from master..sysdatabases D where sid not in(select sid from master..syslogins where name=’sa’)<br>或者<br>select dbid, name AS DB_NAME from master..sysdatabases where sid &lt;&gt; 0x01</p><p>**14：查询某一个表的字段和数据类型<br>**select column_name,data_type from information_schema.columns<br>where table_name = ‘表名’</p><p><strong>15**</strong>：不同服务器数据库之间的数据操作**</p><p><strong>–**</strong>创建链接服务器**</p><p>exec sp_addlinkedserver  ‘ITSV ‘, ‘ ‘, ‘SQLOLEDB ‘, ‘远程服务器名或ip地址 ‘</p><p>exec sp_addlinkedsrvlogin ‘ITSV ‘, ‘false ‘,null, ‘用户名 ‘, ‘密码 ‘</p><p>–查询示例</p><p>select * from ITSV.数据库名.dbo.表名</p><p>–导入示例</p><p>select * into 表 from ITSV.数据库名.dbo.表名</p><p><strong>–**</strong>以后不再使用时删除链接服务器**</p><p>exec sp_dropserver ‘ITSV ‘, ‘droplogins ‘</p><p><strong>–**</strong>连接远程/局域网数据**(openrowset/openquery/opendatasource)</p><p>–1、openrowset</p><p>–查询示例</p><p>select * from openrowset( ‘SQLOLEDB ‘, ‘sql服务器名 ‘; ‘用户名 ‘; ‘密码 ‘,数据库名.dbo.表名)</p><p>–生成本地表</p><p>select * into 表 from openrowset( ‘SQLOLEDB ‘, ‘sql服务器名 ‘; ‘用户名 ‘; ‘密码 ‘,数据库名.dbo.表名)</p><p>–把本地表导入远程表</p><p>insert openrowset( ‘SQLOLEDB ‘, ‘sql服务器名 ‘; ‘用户名 ‘; ‘密码 ‘,数据库名.dbo.表名)</p><p>select *from 本地表</p><p>–更新本地表</p><p>update b</p><p>set b.列A=a.列A</p><p> from openrowset( ‘SQLOLEDB ‘, ‘sql服务器名 ‘; ‘用户名 ‘; ‘密码 ‘,数据库名.dbo.表名)as a inner join 本地表 b</p><p>on a.column1=b.column1</p><p>–openquery用法需要创建一个连接</p><p>–首先创建一个连接创建链接服务器</p><p>exec sp_addlinkedserver  ‘ITSV ‘, ‘ ‘, ‘SQLOLEDB ‘, ‘远程服务器名或ip地址 ‘</p><p>–查询</p><p>select *</p><p>FROM openquery(ITSV, ‘SELECT * FROM 数据库.dbo.表名 ‘)</p><p>–把本地表导入远程表</p><p>insert openquery(ITSV, ‘SELECT * FROM 数据库.dbo.表名 ‘)</p><p>select * from 本地表</p><p>–更新本地表</p><p>update b</p><p>set b.列B=a.列B</p><p>FROM openquery(ITSV, ‘SELECT * FROM 数据库.dbo.表名 ‘) as a </p><p>inner join 本地表 b on a.列A=b.列A</p><p>–3、opendatasource/openrowset</p><p>SELECT  *</p><p>FROM  opendatasource( ‘SQLOLEDB ‘, ‘Data Source=ip/ServerName;User ID=登陆名;Password=密码 ‘ ).test.dbo.roy_ta</p><p>–把本地表导入远程表</p><p>insert opendatasource( ‘SQLOLEDB ‘, ‘Data Source=ip/ServerName;User ID=登陆名;Password=密码 ‘).数据库.dbo.表名</p><p>select * from 本地表 </p><p><strong>SQL Server**</strong>基本函数**</p><p>SQL Server基本函数</p><p><strong>1.字符串函数</strong> 长度与分析用</p><p><strong>1,datalength</strong>(Char_expr) 返回字符串包含字符数,但不包含后面的空格<strong>2,substring</strong>(expression,start,length) 取子串，字符串的下标是从“1”，start为起始位置，length为字符串长度，实际应用中以len(expression)取得其长度<strong>3,right</strong>(char_expr,int_expr) 返回字符串右边第int_expr个字符，还用<strong>left</strong>于之相反<br><strong>4,isnull(</strong> <em>check**</em>_**<em>expression</em> <strong>,</strong> <em>replacement_value</em> **)**如果check_expression為空，則返回replacement_value的值，不為空，就返回check_expression字符操作类</p><p><strong>5,Sp_addtype</strong>自定義數據類型<br>例如：<code>EXEC sp_addtype birthday, datetime, 'NULL'</code></p><pre><code>6,set nocount &amp;#123;on|off&amp;#125;使返回的结果中不包含有关受 Transact-SQL 语句影响的行数的信息。如果存储过程中包含的一些语句并不返回许多实际的数据，则该设置由于大量减少了网络流量，因此可显著提高性能。SET NOCOUNT 设置是在执行或运行时设置，而不是在分析时设置。SET NOCOUNT 为 ON 时，不返回计数（表示受 Transact-SQL 语句影响的行数）。SET NOCOUNT 为 OFF 时，返回计数常识在SQL查询中：from后最多可以跟多少张表或视图：256在SQL语句中出现 Order by,查询时，先排序，后取在SQL中，一个字段的最大容量是8000，而对于nvarchar(4000),由于nvarchar是Unicode码。 SQLServer2000同步复制技术实现步骤一、 预备工作1.发布服务器,订阅服务器都创建一个同名的windows用户,并设置相同的密码,做为发布快照文件夹的有效访问用户--管理工具--计算机管理--用户和组--右键用户--新建用户--建立一个隶属于administrator组的登陆windows的用户（SynUser）2.在发布服务器上,新建一个共享目录,做为发布的快照文件的存放目录,操作:我的电脑--D:\ 新建一个目录,名为: PUB--右键这个新建的目录--属性--共享--选择"共享该文件夹"--通过"权限"按纽来设置具体的用户权限,保证第一步中创建的用户(SynUser) 具有对该文件夹的所有权限--确定3.设置SQL代理(SQLSERVERAGENT)服务的启动用户(发布/订阅服务器均做此设置)开始--程序--管理工具--服务--右键SQLSERVERAGENT--属性--登陆--选择"此账户"--输入或者选择第一步中创建的windows登录用户名（SynUser）--"密码"中输入该用户的密码4.设置SQL Server身份验证模式,解决连接时的权限问题(发布/订阅服务器均做此设置)企业管理器--右键SQL实例--属性--安全性--身份验证--选择"SQL Server 和 Windows"--确定5.在发布服务器和订阅服务器上互相注册企业管理器--右键SQL Server组--新建SQL Server注册...--下一步--可用的服务器中,输入你要注册的远程服务器名 --添加--下一步--连接使用,选择第二个"SQL Server身份验证"--下一步--输入用户名和密码（SynUser）--下一步--选择SQL Server组,也可以创建一个新组--下一步--完成6.对于只能用IP,不能用计算机名的,为其注册服务器别名（此步在实施中没用到） (在连接端配置,比如,在订阅服务器上配置的话,服务器名称中输入的是发布服务器的IP)开始--程序--Microsoft SQL Server--客户端网络实用工具--别名--添加--网络库选择"tcp/ip"--服务器别名输入SQL服务器名--连接参数--服务器名称中输入SQL服务器ip地址--如果你修改了SQL的端口,取消选择"动态决定端口",并输入对应的端口号二、 正式配置1、配置发布服务器打开企业管理器，在发布服务器（B、C、D）上执行以下步骤:(1) 从[工具]下拉菜单的[复制]子菜单中选择[配置发布、订阅服务器和分发]出现配置发布和分发向导(2) [下一步] 选择分发服务器 可以选择把发布服务器自己作为分发服务器或者其他sql的服务器（选择自己）(3) [下一步] 设置快照文件夹采用默认\\servername\Pub(4) [下一步] 自定义配置可以选择:是,让我设置分发数据库属性启用发布服务器或设置发布设置否,使用下列默认设置（推荐）(5) [下一步] 设置分发数据库名称和位置 采用默认值(6) [下一步] 启用发布服务器 选择作为发布的服务器(7) [下一步] 选择需要发布的数据库和发布类型(8) [下一步] 选择注册订阅服务器(9) [下一步] 完成配置2、创建出版物发布服务器B、C、D上(1)从[工具]菜单的[复制]子菜单中选择[创建和管理发布]命令(2)选择要创建出版物的数据库，然后单击[创建发布](3)在[创建发布向导]的提示对话框中单击[下一步]系统就会弹出一个对话框。对话框上的内容是复制的三个类型。我们现在选第一个也就是默认的快照发布(其他两个大家可以去看看帮助)(4)单击[下一步]系统要求指定可以订阅该发布的数据库服务器类型,SQLSERVER允许在不同的数据库如 orACLE或ACCESS之间进行数据复制。但是在这里我们选择运行"SQL SERVER 2000"的数据库服务器(5)单击[下一步]系统就弹出一个定义文章的对话框也就是选择要出版的表注意: 如果前面选择了事务发布 则再这一步中只能选择带有主键的表(6)选择发布名称和描述(7)自定义发布属性 向导提供的选择:是 我将自定义数据筛选,启用匿名订阅和或其他自定义属性否 根据指定方式创建发布 （建议采用自定义的方式）(8)[下一步] 选择筛选发布的方式(9)[下一步] 可以选择是否允许匿名订阅1)如果选择署名订阅,则需要在发布服务器上添加订阅服务器方法: [工具]-&gt;[复制]-&gt;[配置发布、订阅服务器和分发的属性]-&gt;[订阅服务器] 中添加否则在订阅服务器上请求订阅时会出现的提示:改发布不允许匿名订阅如果仍然需要匿名订阅则用以下解决办法[企业管理器]-&gt;[复制]-&gt;[发布内容]-&gt;[属性]-&gt;[订阅选项] 选择允许匿名请求订阅2)如果选择匿名订阅,则配置订阅服务器时不会出现以上提示(10)[下一步] 设置快照 代理程序调度(11)[下一步] 完成配置当完成出版物的创建后创建出版物的数据库也就变成了一个共享数据库有数据srv1.库名..author有字段:id,name,phone,srv2.库名..author有字段:id,name,telphone,adress要求：srv1.库名..author增加记录则srv1.库名..author记录增加srv1.库名..author的phone字段更新，则srv1.库名..author对应字段telphone更新--*/--大致的处理步骤--1.在 srv1 上创建连接服务器,以便在 srv1 中操作 srv2,实现同步exec sp_addlinkedserver 'srv2','','SQLOLEDB','srv2的sql实例名或ip'exec sp_addlinkedsrvlogin 'srv2','false',null,'用户名','密码'go--2.在 srv1 和 srv2 这两台电脑中,启动 msdtc(分布式事务处理服务),并且设置为自动启动。我的电脑--控制面板--管理工具--服务--右键 Distributed Transaction Coordinator--属性--启动--并将启动类型设置为自动启动go--然后创建一个作业定时调用上面的同步处理存储过程就行了企业管理器--管理--SQL Server代理--右键作业--新建作业--"常规"项中输入作业名称--"步骤"项--新建--"步骤名"中输入步骤名--"类型"中选择"Transact-SQL 脚本(TSQL)"--"数据库"选择执行命令的数据库--"命令"中输入要执行的语句: exec p_process--确定--"调度"项--新建调度--"名称"中输入调度名称--"调度类型"中选择你的作业执行安排--如果选择"反复出现"--点"更改"来设置你的时间安排然后将SQL Agent服务启动,并设置为自动启动,否则你的作业不会被执行设置方法:我的电脑--控制面板--管理工具--服务--右键 SQLSERVERAGENT--属性--启动类型--选择"自动启动"--确定.--3.实现同步处理的方法2,定时同步--在srv1中创建如下的同步处理存储过程create proc p_processas--更新修改过的数据update b set name=i.name,telphone=i.telphonefrom srv2.库名.dbo.author b,author iwhere b.id=i.id and(b.name &lt;&gt; i.name or b.telphone &lt;&gt; i.telphone)--插入新增的数据insert srv2.库名.dbo.author(id,name,telphone)select id,name,telphone from author iwhere not exists(select * from srv2.库名.dbo.author where id=i.id)--删除已经删除的数据(如果需要的话)delete bfrom srv2.库名.dbo.author bwhere not exists(select * from author where id=b.id)go</code></pre><h3 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzAwMjk5Mjk3Mw==&amp;mid=2247491760&amp;idx=2&amp;sn=f6b164f632ec5cd4f78a28c24b29cef2&amp;chksm=9ac35e92adb4d784137c8fb664f6b27d1bd69e1bb4d3fd8b139d1e5942acbcdc08897f598f5c&amp;mpshare=1&amp;scene=24&amp;srcid=0811GsnmbOPzUeUSRqru20U7&amp;sharer_sharetime=1597103163923&amp;sharer_shareid=8f0021d867157be678db15b35b9a963d&amp;key=4435c9834d0607a793d1730606c2d723ff1c284311c7133aa50277dd34750806b47b3bbc3068c154ad2454f10a79a5d4ac8ff689d87a9436a887456d98d5b84cd0d7777345e807241f75aae35df2fc6ac30ae696d3c3a8d12efb63bad8db9d2221b26d5e00cf846eef78781a23c549efde12b1cabda8b066932983347949d129&amp;ascene=14&amp;uin=MTk5MzI1NjEyOA==&amp;devicetype=Windows+10+x64&amp;version=62090538&amp;lang=zh_CN&amp;exportkey=A4jhF55K6sI6fzi4VV1U4vo=&amp;pass_ticket=e83yzQu/ia6BTOdDQpH02zY4l0aLYoUOi5QbD2jucebyEmTDempCnWseQkzpe2Ht">https://mp.weixin.qq.com/s?__biz=MzAwMjk5Mjk3Mw==&amp;mid=2247491760&amp;idx=2&amp;sn=f6b164f632ec5cd4f78a28c24b29cef2&amp;chksm=9ac35e92adb4d784137c8fb664f6b27d1bd69e1bb4d3fd8b139d1e5942acbcdc08897f598f5c&amp;mpshare=1&amp;scene=24&amp;srcid=0811GsnmbOPzUeUSRqru20U7&amp;sharer_sharetime=1597103163923&amp;sharer_shareid=8f0021d867157be678db15b35b9a963d&amp;key=4435c9834d0607a793d1730606c2d723ff1c284311c7133aa50277dd34750806b47b3bbc3068c154ad2454f10a79a5d4ac8ff689d87a9436a887456d98d5b84cd0d7777345e807241f75aae35df2fc6ac30ae696d3c3a8d12efb63bad8db9d2221b26d5e00cf846eef78781a23c549efde12b1cabda8b066932983347949d129&amp;ascene=14&amp;uin=MTk5MzI1NjEyOA%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090538&amp;lang=zh_CN&amp;exportkey=A4jhF55K6sI6fzi4VV1U4vo%3D&amp;pass_ticket=e83yzQu%2Fia6BTOdDQpH02zY4l0aLYoUOi5QbD2jucebyEmTDempCnWseQkzpe2Ht</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SQL语句大全&quot;&gt;&lt;a href=&quot;#SQL语句大全&quot; class=&quot;headerlink&quot; title=&quot;SQL语句大全&quot;&gt;&lt;/a&gt;SQL语句大全&lt;/h1&gt;&lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基</summary>
      
    
    
    
    
    <category term="sql" scheme="https://lancewu98.github.io/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>markdown语法</title>
    <link href="https://lancewu98.github.io/2020/08/30/markdown-yu-fa/"/>
    <id>https://lancewu98.github.io/2020/08/30/markdown-yu-fa/</id>
    <published>2020-08-30T04:27:28.000Z</published>
    <updated>2020-08-30T05:44:08.334Z</updated>
    
    <content type="html"><![CDATA[<p>以下内容参考菜鸟教程</p><h2 id="Markdown简介"><a href="#Markdown简介" class="headerlink" title="Markdown简介"></a>Markdown简介</h2><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。<br>Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。<br>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。<br>Markdown 编写的文档后缀为 .md, .markdown。</p><p>PS: Typora 编辑器，永远滴神</p><h2 id="Markdown-标题"><a href="#Markdown-标题" class="headerlink" title="Markdown 标题"></a>Markdown 标题</h2><p>Markdown 标题有两种格式。</p><h3 id="1、使用-和-标记一级和二级标题"><a href="#1、使用-和-标记一级和二级标题" class="headerlink" title="1、使用 = 和 - 标记一级和二级标题"></a>1、使用 = 和 - 标记一级和二级标题</h3><p>= 和 - 标记语法格式如下：</p><pre><code>我展示的是一级标题(比较大)=================我展示的是二级标题-----------------</code></pre><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/01986C87-7E19-4497-878E-AE996AFC088E.jpg" alt="img"></p><h3 id="2、使用-号标记"><a href="#2、使用-号标记" class="headerlink" title="2、使用 # 号标记"></a>2、使用 # 号标记</h3><p>使用 <strong>#</strong> 号可表示 1-6 级标题，一级标题对应一个 <strong>#</strong> 号，二级标题对应两个 <strong>#</strong> 号，以此类推。</p><pre><code># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题</code></pre><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/md2.gif" alt="img"></p><h2 id="Markdown-段落"><a href="#Markdown-段落" class="headerlink" title="Markdown 段落"></a>Markdown 段落</h2><p>Markdown 段落没有特殊的格式，直接编写文字就好，<strong>段落的换行是使用两个以上空格加上回车</strong>。</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/36A89BDA-A062-4D66-A41B-0EBEE7891AB9.jpg" alt="img"></p><p>当然也可以在段落后面使用一个空行来表示重新开始一个段落。</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/3F254936-778E-417A-BEF2-467116A55D00.jpg" alt="img"></p><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>Markdown 可以使用以下几种字体：</p><pre><code>*斜体文本*_斜体文本_**粗体文本**__粗体文本__***粗斜体文本***___粗斜体文本___</code></pre><p>显示效果如下所示：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/md3.gif" alt="img"></p><hr><h3 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h3><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p><pre><code>**** * ******- - -----------</code></pre><p>显示效果如下所示：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/3F46EAA9-DADE-48FD-99AA-DF7BEBFAA4FA.jpg" alt="img"></p><hr><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 <strong>~~</strong> 即可，实例如下：</p><pre><code>RUNOOB.COMGOOGLE.COM~~BAIDU.COM~~</code></pre><p>显示效果如下所示：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/B5270A31-15D0-410B-AE1D-B9655B8F331C.jpg" alt="img"></p><hr><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>下划线可以通过 HTML 的 <strong><u> </u></strong> 标签来实现：</p><pre><code>&lt;u&gt;带下划线文本&lt;/u&gt;</code></pre><p>显示效果如下所示：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/05A27273-B66D-43DE-A3DB-0D32FF024093.jpg" alt="img"></p><hr><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>脚注是对文本的补充说明。</p><p>Markdown 脚注的格式如下:</p><pre><code>[^要注明的文本]</code></pre><p>以下实例演示了脚注的用法：</p><pre><code>创建脚注格式类似这样 [^RUNOOB]。[^RUNOOB]: 菜鸟教程 -- 学的不仅是技术，更是梦想！！！</code></pre><p>演示效果如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/md5.gif" alt="img"></p><h2 id="Markdown-列表"><a href="#Markdown-列表" class="headerlink" title="Markdown 列表"></a>Markdown 列表</h2><p>Markdown 支持有序列表和无序列表。</p><p>无序列表使用星号(*<strong>**)、加号(</strong>+<strong>)或是减号(</strong>-**)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：</p><pre><code>* 第一项* 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项</code></pre><p>显示结果如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/89446A8E-6D83-4666-AACC-980145D5F070.jpg" alt="img"></p><p>有序列表使用数字并加上 <strong>.</strong> 号来表示，如：</p><pre><code>1. 第一项2. 第二项3. 第三项</code></pre><p>显示结果如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/560384BB-2B00-41D5-ACF2-18972F7F2775.jpg" alt="img"></p><h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3><p>列表嵌套只需在子列表中的选项前面添加四个空格即可：</p><pre><code>1. 第一项：    - 第一项嵌套的第一个元素    - 第一项嵌套的第二个元素2. 第二项：    - 第二项嵌套的第一个元素    - 第二项嵌套的第二个元素</code></pre><p>显示结果如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/8ED795DA-F124-4E70-BA71-57CD9CF958A4.jpg" alt="img"></p><h2 id="Markdown-区块"><a href="#Markdown-区块" class="headerlink" title="Markdown 区块"></a>Markdown 区块</h2><p>Markdown 区块引用是在段落开头使用 <strong>&gt;</strong> 符号 ，然后后面紧跟一个<strong>空格</strong>符号：</p><pre><code>&gt; 区块引用&gt; 菜鸟教程&gt; 学的不仅是技术更是梦想</code></pre><p>显示结果如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/DFE1124E-BC38-4C12-B7AC-053E560D4C9C.jpg" alt="img"></p><p>另外区块是可以嵌套的，一个 <strong>&gt;</strong> 符号是最外层，两个 <strong>&gt;</strong> 符号是第一层嵌套，以此类推：</p><pre><code>&gt; 最外层&gt; &gt; 第一层嵌套&gt; &gt; &gt; 第二层嵌套</code></pre><p>显示结果如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/AA0A4A6A-33A7-48C7-971F-73FFC8FE85B0.jpg" alt="img"></p><h3 id="区块中使用列表"><a href="#区块中使用列表" class="headerlink" title="区块中使用列表"></a>区块中使用列表</h3><p>区块中使用列表实例如下：</p><pre><code>&gt; 区块中使用列表&gt; 1. 第一项&gt; 2. 第二项&gt; + 第一项&gt; + 第二项&gt; + 第三项</code></pre><p>显示结果如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/E3BF6399-6483-4C7A-8502-AE75E8D66C96.jpg" alt="img"></p><h3 id="列表中使用区块"><a href="#列表中使用区块" class="headerlink" title="列表中使用区块"></a>列表中使用区块</h3><p>如果要在列表项目内放进区块，那么就需要在 <strong>&gt;</strong> 前添加四个空格的缩进。</p><p>区块中使用列表实例如下：</p><pre><code>* 第一项    &gt; 菜鸟教程    &gt; 学的不仅是技术更是梦想* 第二项</code></pre><p>显示结果如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/1B894FB4-53AC-4E2D-BA30-F4AE4DFA8B97.jpg" alt="img"></p><h2 id="Markdown-代码"><a href="#Markdown-代码" class="headerlink" title="Markdown 代码"></a>Markdown 代码</h2><p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来（**`**），例如：</p><pre><code>`printf()` 函数</code></pre><p>显示结果如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/C928FDA3-E0A7-4AFF-AB2A-B3AF44F93DF9.jpg" alt="img"></p><h3 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h3><p>代码区块使用 <strong>4 个空格</strong>或者一个<strong>制表符（Tab 键）</strong>。</p><p>实例如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/55EDFE05-5F27-458E-AFE0-7B96685C9603.jpg" alt="img"></p><p>显示结果如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/6DC89E5C-B41A-4938-97D8-D7D06B879F91.jpg" alt="img"></p><p>你也可以用 <strong>```</strong> 包裹一段代码，并指定一种语言（也可以不指定）：</p><pre><code>​```javascript$(document).ready(function () &amp;#123;    alert('RUNOOB');&amp;#125;);​```</code></pre><p>显示结果如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/88F52386-2F98-4D7E-8935-E43BECA6D868.jpg" alt="img"></p><h2 id="Markdown-链接"><a href="#Markdown-链接" class="headerlink" title="Markdown 链接"></a>Markdown 链接</h2><p>链接使用方法如下：</p><pre><code>[链接名称](链接地址)或者&lt;链接地址&gt;</code></pre><p>例如：</p><pre><code>这是一个链接 [菜鸟教程](https://www.runoob.com)</code></pre><p>显示结果如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/49E6CB42-F780-4DA6-8290-DC757B51FB9A.jpg" alt="img"></p><p>直接使用链接地址：</p><pre><code>&lt;https://www.runoob.com&gt;</code></pre><p>显示结果如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/9BFF60A1-DD71-4B63-987B-4665B31C7787.jpg" alt="img"></p><h3 id="高级链接"><a href="#高级链接" class="headerlink" title="高级链接"></a>高级链接</h3><p>我们可以通过变量来设置一个链接，变量赋值在文档末尾进行：</p><pre><code>这个链接用 1 作为网址变量 [Google][1]这个链接用 runoob 作为网址变量 [Runoob][runoob]然后在文档的结尾为变量赋值（网址）  [1]: http://www.google.com/  [runoob]: http://www.runoob.com/</code></pre><p>显示结果如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/EC3ED5D2-4F0D-492A-81B3-D485623D1A9E.jpg" alt="img"></p><h2 id="Markdown-图片"><a href="#Markdown-图片" class="headerlink" title="Markdown 图片"></a>Markdown 图片</h2><p>Markdown 图片语法格式如下：</p><pre><code>![alt 属性文本](图片地址)![alt 属性文本](图片地址 "可选标题")</code></pre><ul><li>开头一个感叹号 !</li><li>接着一个方括号，里面放上图片的替代文字</li><li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。</li></ul><p>使用实例：</p><pre><code>![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png)![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png "RUNOOB")</code></pre><p>显示结果如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/A042DF30-C232-46F3-8436-7D6C35351BBD.jpg" alt="img"></p><p>当然，你也可以像网址那样对图片网址使用变量:</p><pre><code>这个链接用 1 作为网址变量 [RUNOOB][1].然后在文档的结尾为变量赋值（网址）[1]: http://static.runoob.com/images/runoob-logo.png</code></pre><p>显示结果如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/75AA6EBF-CC57-44A6-A585-5EE3DD94E42A.jpg" alt="img"></p><p>Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 <img> 标签。</p><pre><code>&lt;img src="http://static.runoob.com/images/runoob-logo.png" width="50%"&gt;</code></pre><p>显示结果如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/55F2A67D-F4BD-4960-AC55-DC690A415878.jpg" alt="img"></p><h2 id="Markdown-表格"><a href="#Markdown-表格" class="headerlink" title="Markdown 表格"></a>Markdown 表格</h2><p>Markdown 制作表格使用 <strong>|</strong> 来分隔不同的单元格，使用 <strong>-</strong> 来分隔表头和其他行。</p><p>语法格式如下：</p><pre><code>|  表头   | 表头  ||  ----  | ----  || 单元格  | 单元格 || 单元格  | 单元格 |</code></pre><p>以上代码显示结果如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/23EACC50-38E0-4284-B99A-6BC22E284BAC.jpg" alt="img"></p><p>对齐方式</p><p><strong>我们可以设置表格的对齐方式：</strong></p><ul><li><strong>-:</strong> 设置内容和标题栏居右对齐。</li><li><strong>:-</strong> 设置内容和标题栏居左对齐。</li><li><strong>:-:</strong> 设置内容和标题栏居中对齐。</li></ul><p>实例如下：</p><pre><code>| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 |</code></pre><p>以上代码显示结果如下：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/87DE9D5C-44FB-4693-8735-194D3779EC3E.jpg" alt="img"></p><h2 id="Markdown-高级技巧"><a href="#Markdown-高级技巧" class="headerlink" title="Markdown 高级技巧"></a>Markdown 高级技巧</h2><h3 id="支持的-HTML-元素"><a href="#支持的-HTML-元素" class="headerlink" title="支持的 HTML 元素"></a>支持的 HTML 元素</h3><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。</p><p>目前支持的 HTML 元素有：<code>&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;</code>等 ，如：</p><pre><code>使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑</code></pre><p>输出结果为：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/81999271-F914-428D-B7BF-164BDC67CAAC.jpg" alt="img"></p><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：</p><pre><code>**文本加粗** \*\* 正常显示星号 \*\*</code></pre><p>输出结果为：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/CA0E0162-0C48-41CD-B57A-CB32A4287C02.jpg" alt="img"></p><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><pre><code>\   反斜线`   反引号*   星号_   下划线&amp;#123;&amp;#125;  花括号[]  方括号()  小括号#   井字号+   加号-   减号.   英文句点!   感叹号</code></pre><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p>当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：</p><pre><code>$$\mathbf&amp;#123;V&amp;#125;_1 \times \mathbf&amp;#123;V&amp;#125;_2 =  \begin&amp;#123;vmatrix&amp;#125; \mathbf&amp;#123;i&amp;#125; &amp; \mathbf&amp;#123;j&amp;#125; &amp; \mathbf&amp;#123;k&amp;#125; \\\frac&amp;#123;\partial X&amp;#125;&amp;#123;\partial u&amp;#125; &amp;  \frac&amp;#123;\partial Y&amp;#125;&amp;#123;\partial u&amp;#125; &amp; 0 \\\frac&amp;#123;\partial X&amp;#125;&amp;#123;\partial v&amp;#125; &amp;  \frac&amp;#123;\partial Y&amp;#125;&amp;#123;\partial v&amp;#125; &amp; 0 \\\end&amp;#123;vmatrix&amp;#125;$&amp;#123;$tep1&amp;#125;&amp;#123;\style&amp;#123;visibility:hidden&amp;#125;&amp;#123;(x+1)(x+1)&amp;#125;&amp;#125;$$</code></pre><p>输出结果为：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/1061D800-D44C-436D-A1EA-1CBDA95A5209.jpg" alt="img"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以下内容参考菜鸟教程&lt;/p&gt;
&lt;h2 id=&quot;Markdown简介&quot;&gt;&lt;a href=&quot;#Markdown简介&quot; class=&quot;headerlink&quot; title=&quot;Markdown简介&quot;&gt;&lt;/a&gt;Markdown简介&lt;/h2&gt;&lt;p&gt;Markdown 是一种轻量级标记语言，</summary>
      
    
    
    
    
    <category term="markdown" scheme="https://lancewu98.github.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot的Starter工作原理</title>
    <link href="https://lancewu98.github.io/2020/08/30/springboot-de-starter-gong-zuo-yuan-li/"/>
    <id>https://lancewu98.github.io/2020/08/30/springboot-de-starter-gong-zuo-yuan-li/</id>
    <published>2020-08-30T04:23:45.000Z</published>
    <updated>2020-08-30T10:15:57.516Z</updated>
    
    <content type="html"><![CDATA[<h2 id="生产资料，优先到位"><a href="#生产资料，优先到位" class="headerlink" title="生产资料，优先到位"></a>生产资料，优先到位</h2><p>生产资料就是用于正常生产工作所需要的一切东西。<br>从古代战争来讲，那就是“兵马未动，粮草先行”。所以粮草就是生产资料。<br>从我们码农来讲，正常开发所需要的都是生产资料，这里有一块很重要的资料，就是所有依赖的第三方jar包。<br>我们不需要重复造轮子，也不需要从零开始，所以直接拿来就用，拿来的其实就是jar包。<br>jar包只是一些基础代码，而且很多原本和Spring或SpringBoot没有关系，现在要和Spring或SpringBoot整合使用，就必须按Spring或SpringBoot的Style进行。</p><h2 id="传统的和Spring整合的方式"><a href="#传统的和Spring整合的方式" class="headerlink" title="传统的和Spring整合的方式"></a>传统的和Spring整合的方式</h2><p>还以MyBatis和Spring整合为例，因为每个Java开发人员对它都非常熟悉。<br>要完成这个整合，需要三个方面的jar包：<br>一是Spring的jar包。<br>二是MyBatis的jar包。<br>三是整合时使用的jar包。<br>这三方面的jar包都需要自己手动一一引入。<br>引入Spring的jar包：</p><p><img src="https://i.loli.net/2020/08/30/CjyuOmdUPEZFVAt.jpg" alt="1.jpg"></p><p>引入MyBatis的jar包：</p><p><img src="https://i.loli.net/2020/08/30/WfHw7CXJYagGMOU.jpg" alt="2.jpg"></p><p>引入整合的jar包：</p><p><img src="https://i.loli.net/2020/08/30/LOwPBKrpUtfQEd1.jpg" alt="3.jpg"></p><p>还有一个问题，就是当引入的jar包足够多时，jar包之间的版本号有时会有冲突，需要自己慢慢测试，颇为麻烦。<br>jar包导入之后，就该自己写代码进行Bean注册了，因为Spring的Style就是Bean注册。</p><p><img src="https://i.loli.net/2020/08/30/ZnrGz1BTqI5oapX.jpg" alt="4.jpg"></p><p>主要包括四方面内容：<br>1、注册SqlSessionFactory这个Bean<br>2、指定mybatis的mybatis-config.xml配置文件路径<br>3、指定mybatis的mapper.xml映射文件的路径<br>4、指定源码包路径并扫描所有@Mapper注解接口</p><p>这里面有两个问题，不是十分友好：<br>1、jar包版本号问题，有时确实麻烦<br>2、注册Bean的代码几乎都一样，而且每次都要手动注册</p><h2 id="SpringBoot帮你解决"><a href="#SpringBoot帮你解决" class="headerlink" title="SpringBoot帮你解决"></a>SpringBoot帮你解决</h2><p>对于jar包的版本号问题，SpringBoot帮你搞定，它经过测试，把常用的依赖及其适合的版本号都通过依赖管理的方式包含在pom文件中。</p><p><img src="https://i.loli.net/2020/08/30/oLGInit19PO6ZUE.jpg" alt="5.jpg"></p><p>注意，这里只是依赖管理，并不是引入依赖。如需使用的话，还需要引入，只不过不用再指定版本号了。<br>对于注册Bean的问题，SpringBoot也帮你搞定，它把这些注册代码都已写好，然后通过各种“条件注解”来进行自动配置，所以最终会不会被注册，还要看运行时的“条件”。<br>这其实就是SpringBoot的自动配置了，具体可参考前两篇文章。</p><h2 id="Starter就是一个启用入口"><a href="#Starter就是一个启用入口" class="headerlink" title="Starter就是一个启用入口"></a>Starter就是一个启用入口</h2><p>汽车造好之后，就只给我们留了一个一键启动的按键，踩着刹车按一下就启动了，至于按键背后做的事情，我们无需知道，只有这样才可以大范围推广。<br>同理，Starter也是这样一个东西，只要引入之后，并在application.yml文件中进行一些简单的配置或根本无须配置，直接启动后就可以用了。<br>Starter其实就是一个jar包，在pom中引入一个starter其实就是引入了一个jar包。<br>而且很多时候，这个starter对应的jar包是个空的，里面并没有任何类和接口。</p><p><img src="https://i.loli.net/2020/08/30/BtwIaRNr6g4JWbZ.png" alt="6.png"></p><p>那这个空的jar包有何意义呢？它的意义就在于为了引入有意义的其它jar包，因为这些jar包都是基于Maven的，因此jar包的pom文件中包含了其它依赖。</p><p><img src="https://i.loli.net/2020/08/30/q3V1x8QrbPWySAz.png" alt="7.png"></p><p>我们可以看到这个MyBatis的Starter就引入了正好需要的四类jar包：<br>1、Spring或SpringBoot相关的jar包<br>2、MyBatis的jar包<br>3、MyBatis和Spring整合的jar包<br>4、自动配置（也就是自动注册Bean）的jar包</p><p>这样一来，要完成MyBatis和Spring整合的所有jar包都凑齐了。而且自动注册Bean这些模板代码也已经有了。<br>这里面也就自动配置jar包稍微特殊一点，它里面包含一些带有“条件注解”的Bean注册。所以这些代码需要在SpringBoot中运行。<br>由于很多自动配置jar包都是第三方提供的，所以一定要告诉SpringBoot一声，让SpringBoot来执行它，这样才可以。<br>就像一键启动按钮一样，你至少要按一下吧，不能通过意念控制的。</p><p>下面是MyBatis的自动配置jar包：</p><p><img src="https://i.loli.net/2020/08/30/3COU6bvqelZI7x9.png" alt="8.png"></p><p>这个jar包里包含了一个特殊约定的文件，就是spring.factories，它位于jar包里的META-INF目录下：</p><p><img src="https://i.loli.net/2020/08/30/wzM6ja8cOYlukoJ.png" alt="9.png"></p><p>这个文件的内容如下：</p><p><img src="https://i.loli.net/2020/08/30/a1nlQY9SHokjVfX.png" alt="10.png"></p><p>首先注释已经告诉我们了，这是自动配置。<br>具体内容是一个key/value类型的内容，key是固定的，就是SpringBoot自动配置的注解EnableAutoConfiguration的全名。<br>value就是第三方提供的自动配置类MybatisAutoConfiguration的全名。<br>这其实就是一个挂接，通过这种方式，第三方提供的自动配置就可以被SpringBoot执行了，然后Bean就会被注册了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Starter使用Maven规则引入所有需要的依赖jar包，和自动配置jar包。<br>自动配置jar包使用spring.factories文件把自己挂接到SpringBoot以便被执行。<br>带来的简便：<br>原来所有的问题，现在都变为仅仅在pom中引入一个starter而已。</p><h2 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247491274&amp;idx=2&amp;sn=73f2c1f52794b082bfc63737b0d98f5e&amp;chksm=ebd75fcbdca0d6ddf39898a772661c7f28640bfe78f2f7925ed52961619f1a2fdc48180f5908&amp;mpshare=1&amp;scene=24&amp;srcid=0807E1nR0LMmcSova0BWC2CD&amp;sharer_sharetime=1596774789117&amp;sharer_shareid=8f0021d867157be678db15b35b9a963d&amp;key=d346675dd6ecd6cc58e12f8bb9f89e1c5d0636ae83160b77a957a24bf3569baa54806841683d66dbca93b9421832070a682f7e2a9825aec7a854c2c95a8671a1b9f1c1954f7c84051e8e48de449ec28305df080865e04b7924b293fd5a73afa1b6f9f2ac3735097c34ec6642a1cc8525336489e79ffaec7079476613a191be72&amp;ascene=14&amp;uin=MTk5MzI1NjEyOA==&amp;devicetype=Windows+10+x64&amp;version=62090538&amp;lang=zh_CN&amp;exportkey=A3BlpTpxh/PJDBneV/VJ0mg=&amp;pass_ticket=e83yzQu/ia6BTOdDQpH02zY4l0aLYoUOi5QbD2jucebyEmTDempCnWseQkzpe2Ht">https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;mid=2247491274&amp;idx=2&amp;sn=73f2c1f52794b082bfc63737b0d98f5e&amp;chksm=ebd75fcbdca0d6ddf39898a772661c7f28640bfe78f2f7925ed52961619f1a2fdc48180f5908&amp;mpshare=1&amp;scene=24&amp;srcid=0807E1nR0LMmcSova0BWC2CD&amp;sharer_sharetime=1596774789117&amp;sharer_shareid=8f0021d867157be678db15b35b9a963d&amp;key=d346675dd6ecd6cc58e12f8bb9f89e1c5d0636ae83160b77a957a24bf3569baa54806841683d66dbca93b9421832070a682f7e2a9825aec7a854c2c95a8671a1b9f1c1954f7c84051e8e48de449ec28305df080865e04b7924b293fd5a73afa1b6f9f2ac3735097c34ec6642a1cc8525336489e79ffaec7079476613a191be72&amp;ascene=14&amp;uin=MTk5MzI1NjEyOA%3D%3D&amp;devicetype=Windows+10+x64&amp;version=62090538&amp;lang=zh_CN&amp;exportkey=A3BlpTpxh%2FPJDBneV%2FVJ0mg%3D&amp;pass_ticket=e83yzQu%2Fia6BTOdDQpH02zY4l0aLYoUOi5QbD2jucebyEmTDempCnWseQkzpe2Ht</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;生产资料，优先到位&quot;&gt;&lt;a href=&quot;#生产资料，优先到位&quot; class=&quot;headerlink&quot; title=&quot;生产资料，优先到位&quot;&gt;&lt;/a&gt;生产资料，优先到位&lt;/h2&gt;&lt;p&gt;生产资料就是用于正常生产工作所需要的一切东西。&lt;br&gt;从古代战争来讲，那就是“兵马未</summary>
      
    
    
    
    
    <category term="java" scheme="https://lancewu98.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>hexo搭建步骤及踩到的坑</title>
    <link href="https://lancewu98.github.io/2020/08/22/hexo-da-jian-bu-zou-ji-cai-dao-de-keng/"/>
    <id>https://lancewu98.github.io/2020/08/22/hexo-da-jian-bu-zou-ji-cai-dao-de-keng/</id>
    <published>2020-08-22T04:51:43.000Z</published>
    <updated>2021-07-27T02:59:58.373Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hexo安装步骤"><a href="#hexo安装步骤" class="headerlink" title="hexo安装步骤"></a>hexo安装步骤</h2><p>1.安装nodejs</p><p>坑：尽量别装太新的版本，不然启动hexo会出错，像v10.15.0的就可以了，这个直接百度“nodejs以往版本”就行</p><p>环境变量：win10不赘述，linux需要编辑/etc/profile文件加入环境变量，然后sudo su进入管理员模式，再 source /etc/profile使得环境变量生效（每次打开终端都需要这样，暂无解决办法）</p><p>配置完环境变量后，cmd输入 node -v和 npm -v有显示版本号即安装成功</p><p>2.配置阿里镜像</p><p>cmd执行 npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a> (registry前面是两条杠，不知道为啥编辑器里是两道杠，在博客里变成了一条)</p><p>完成之后输入 cnpm -v，有版本信息即可，registry有taobao即配置阿里镜像成功</p><p>3.安装hexo</p><p>cmd执行 cnpm install -g hexo-cli</p><p>完成之后输入hexo -v，有版本信息即可</p><hr><h2 id="hexo博客具体使用"><a href="#hexo博客具体使用" class="headerlink" title="hexo博客具体使用"></a>hexo博客具体使用</h2><p>1.随便建立一个文件夹放置博客文件</p><p>2.进入文件夹，cmd执行 hexo init<br>此处win10直接执行，linux要加sudo，执行完成即创建了一个初始的hexo博客</p><p>3.启动hexo博客</p><p>cmd执行 hexo s（默认是localhost：4000，端口有误自行百度）s代表start或server吧大概</p><p>4.建立一篇新文章</p><p>先在cmd里ctrl+c退出运行中的博客，执行 hexo n “文章名”即可</p><p>5.修改文章</p><p>在source/_posts/目录下有刚产生的文章，直接编辑即可</p><p>6.将文章生成到博客</p><p>执行cd ../..返回初始目录，执行 hexo clean，再执行 hexo g即可（clean其实可以不执行的，经过测验，clean的作用是删掉hexo文件夹下的public文件夹，功能有点像是刷新修改的配置文件，重新生成js之类的内容）</p><p>7.再次打开博客即可看到新文章</p><p>执行 hexo s</p><hr><h2 id="hexo博客部署到github"><a href="#hexo博客部署到github" class="headerlink" title="hexo博客部署到github"></a>hexo博客部署到github</h2><p>1.安装git并且配置git账号信息</p><p>  安装不赘述，记得安装要选git bash且记得配置环境变量</p><p>  git config –global user.name “你的github用户名”<br>  git config –global user.email “你的github账号注册的邮箱”</p><p>  完成后可以执行 git config –list查看是否设置成功</p><p>2.在github建立一个github page的仓库</p><p>  和创建普通仓库步骤差不多，只是仓库名必须是“你的github账号用户名（非昵称）.github.io”</p><p>3.安装部署插件</p><p>  cmd执行 cnpm install –save hexo-deployer-git</p><p>4.设置部署配置</p><p>  打开博客目录下的_config.yml文件，拉到最底下deploy处,如下填写（冒号后面必须有空格）：</p><p>  deploy:<br>     type: git<br>     repo: 你上面创建的仓库的地址 (https和ssh都可以)<br>     branch: master</p><p>5.部署到远端</p><p>  cmd执行 hexo d，期间需要输入github的账号和密码，完成之后github仓库里会出现博客生成的内容</p><p>6.浏览器访问</p><p>  <a href="https://xxx.github.io/">https://xxx.github.io</a></p><p>  此处遇到了最大的一个坑，且折腾了非常久，坑是浏览时会显示禁止访问，没有授权<br>  解决过程：<br>  最开始尝试的方法是本机生成ssh key并在github里添加，但是还是不行（暂不确定会不会只是解决问题的其中一步）<br>  最后是找了挺久才找到正确的方法：</p><p>  1.打开 <a href="http://tool.chinaz.com/dns%EF%BC%8C%E8%BE%93%E5%85%A5%E2%80%9Cxxx.github.io%E2%80%9D%E4%BB%A5%E6%9F%A5%E8%AF%A2%E5%8D%9A%E5%AE%A2ip%E5%9C%B0%E5%9D%80">http://tool.chinaz.com/dns，输入“xxx.github.io”以查询博客ip地址</a></p><p>  2.记下第一条字样 “[美国 Github+Fastly节点]”前的ip地址</p><p>  3.用记事本打开C:\Windows\System32\drivers\etc里的hosts文件，注意需要管理员权限，不然无法保存修改（不知道为什么我的win10右键没有管理员运行这一项，所以我的操作是直接复制hosts里面的内容，然后删除，创建个同名txt再将原内容复制进去）</p><p>  4.在文件最后加上“刚才查询到的ip地址 xxx.github.io”</p><p>  5.cmd执行 ipconfig /flushdns即可</p><hr><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这个过程确实不麻烦，主要是之前试过的几次，都是在最后一步的坑里跌住，执行xxx.github.io时总是404，添加了https都不管用，之后这次变成了没有授权。。反正一路吃s，最后才弄完的，之后再考虑弄到gitee上，毕竟比较快。<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span><br>博客主题参考：<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md">https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;hexo安装步骤&quot;&gt;&lt;a href=&quot;#hexo安装步骤&quot; class=&quot;headerlink&quot; title=&quot;hexo安装步骤&quot;&gt;&lt;/a&gt;hexo安装步骤&lt;/h2&gt;&lt;p&gt;1.安装nodejs&lt;/p&gt;
&lt;p&gt;坑：尽量别装太新的版本，不然启动hexo会出错，像v10</summary>
      
    
    
    
    
    <category term="hexo" scheme="https://lancewu98.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>demo</title>
    <link href="https://lancewu98.github.io/2020/08/22/demo/"/>
    <id>https://lancewu98.github.io/2020/08/22/demo/</id>
    <published>2020-08-22T03:41:53.000Z</published>
    <updated>2020-08-29T12:23:34.163Z</updated>
    
    <content type="html"><![CDATA[<p>##第一章</p><p>内容</p><hr><p>##第二章</p><p>内容</p><hr><p>##参考文献</p><p><a href="http://www.baidu.com/">www.baidu.com</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;##第一章&lt;/p&gt;
&lt;p&gt;内容&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;##第二章&lt;/p&gt;
&lt;p&gt;内容&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;##参考文献&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.baidu.com/&quot;&gt;www.baidu.com&lt;/a&gt;&lt;/p&gt;
&lt;script&gt;
    </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://lancewu98.github.io/2020/08/22/hello-world/"/>
    <id>https://lancewu98.github.io/2020/08/22/hello-world/</id>
    <published>2020-08-22T03:36:01.976Z</published>
    <updated>2020-08-22T03:36:01.976Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
